{"version":3,"file":"index.js","sources":["../node_modules/tslib/tslib.es6.js","../../node_modules/tslib/tslib.es6.js","../../src/MicroblinkSDK/local/LocalSDKBackend.ts","../../src/MicroblinkSDK/worker/Messages.ts","../../src/MicroblinkSDK/DataStructures.ts","../../src/MicroblinkSDK/MetadataCallbacks.ts","../../src/MicroblinkSDK/worker/WorkerSDKBackend.ts","../../src/MicroblinkSDK/FrameCapture.ts","../../src/MicroblinkSDK/VideoRecognizer.ts","../../src/MicroblinkSDK/WasmLoadSettings.ts","../../src/defaultWasmModule.ts","../../src/MicroblinkSDK/MicroblinkSDK.ts","../../src/Recognizers/BlinkBarcode/BarcodeData.ts","../../src/Recognizers/BlinkID/IDBarcode/IdBarcodeRecognizer.ts","../../src/Recognizers/BlinkID/MRTD/MrtdStructures.ts","../src/index.ts","../../src/MicroblinkSDK/LoadProgressUtils.ts","../../src/Recognizers/BlinkID/MRTD/MrtdRecognizer.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { CapturedFrame } from \"../FrameCapture\"\nimport\n{\n    RecognizerResultState,\n    RecognizerRunner,\n    WasmModuleProxy,\n    WasmSDK,\n    Recognizer\n} from \"../DataStructures\"\nimport { MetadataCallbacks } from \"../MetadataCallbacks\"\nimport { ClearTimeoutCallback } from '../ClearTimeoutCallback'\n\n////////////////////////////////////////////////\n// Local Proxy implementation\n////////////////////////////////////////////////\n\nclass WasmLocalRecognizerRunner implements RecognizerRunner\n{\n    private nativeRecognizerRunner: any;\n\n    constructor( nativeRecognizerRunner: any )\n    {\n        this.nativeRecognizerRunner = nativeRecognizerRunner;\n    }\n\n    processImage( image: CapturedFrame ): Promise< RecognizerResultState >\n    {\n        const result: number = this.nativeRecognizerRunner.processImage( image );\n        return Promise.resolve( result );\n    }\n\n    reconfigureRecognizers( recognizers: Array< Recognizer >, allowMultipleResults: boolean ): Promise< void >\n    {\n        return new Promise\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                try\n                {\n                    this.nativeRecognizerRunner.reconfigureRecognizers( recognizers, allowMultipleResults );\n                    resolve();\n                }\n                catch( error )\n                {\n                    reject( error );\n                }\n            }\n        );\n    }\n\n    setMetadataCallbacks( metadataCallbacks: MetadataCallbacks ): Promise< void >\n    {\n        this.nativeRecognizerRunner.setJSDelegate( metadataCallbacks );\n        return Promise.resolve();\n    }\n\n    resetRecognizers( hardReset: boolean ): Promise< void >\n    {\n        this.nativeRecognizerRunner.resetRecognizers( hardReset );\n        return Promise.resolve();\n    }\n\n    setDetectionOnlyMode( detectionOnly: boolean ): Promise< void >\n    {\n        this.nativeRecognizerRunner.setDetectionOnlyMode( detectionOnly );\n        return Promise.resolve();\n    }\n\n    setClearTimeoutCallback( clearTimeoutCallback: ClearTimeoutCallback | null ): Promise< void >\n    {\n        this.nativeRecognizerRunner.setClearTimeoutCallback( clearTimeoutCallback );\n        return Promise.resolve();\n    }\n\n    setCameraPreviewMirrored( mirrored: boolean ): Promise< void >\n    {\n        this.nativeRecognizerRunner.setCameraPreviewMirrored( mirrored );\n        return Promise.resolve();\n    }\n\n    delete(): Promise< void >\n    {\n        this.nativeRecognizerRunner.delete();\n        this.nativeRecognizerRunner = null;\n        return Promise.resolve();\n    }\n};\n\nclass WasmModuleLocalProxy implements WasmModuleProxy\n{\n    private readonly realWasmModule: any;\n\n    constructor( realWasmModule: any )\n    {\n        this.realWasmModule = realWasmModule;\n    }\n\n    newRecognizer( className: string, ...constructorArgs: any[] ): Promise< Recognizer >\n    {\n        const nativeRecognizer: Recognizer = new this.realWasmModule[ className ]( ...constructorArgs );\n        ( nativeRecognizer as any ).recognizerName = className;\n        return Promise.resolve( nativeRecognizer );\n    }\n\n    createRecognizerRunner( recognizers: Array< Recognizer >, allowMultipleResults: boolean = false, metadataCallbacks: MetadataCallbacks = {} ): Promise< RecognizerRunner >\n    {\n        const nativeRecognizerRunner = new this.realWasmModule.RecognizerRunner( recognizers, allowMultipleResults, metadataCallbacks );\n        return Promise.resolve( new WasmLocalRecognizerRunner( nativeRecognizerRunner ) );\n    }\n};\n\nexport class WasmSDKLocal implements WasmSDK\n{\n    readonly mbWasmModule: WasmModuleProxy;\n\n    constructor( wasmModule: any )\n    {\n        // this.mbWasmModule = new Proxy( new WasmModuleLocalProxy( wasmModule ), wasmModuleLocalProxyHandler );\n        this.mbWasmModule = new WasmModuleLocalProxy( wasmModule );\n    }\n}\n","import { CapturedFrame } from \"../FrameCapture\";\nimport { WasmSDKLoadSettings } from '../WasmLoadSettings'\n\nlet nextMessageID = 0;\n\nfunction getNextMessageID()\n{\n    const msgId = nextMessageID;\n    nextMessageID = nextMessageID + 1;\n    return msgId;\n}\n\n//////////////////////////////////////////\n// Request messages\n//////////////////////////////////////////\n\nexport interface RequestMessage\n{\n    readonly action: string;\n    readonly messageID: number;\n}\n\nexport interface TransferrableMessage\n{\n    getTransferrables(): Array< Transferable >;\n}\n\nabstract class BaseRequestMessage implements RequestMessage\n{\n    readonly action: string;\n    readonly messageID: number;\n\n    protected constructor( action: string )\n    {\n        this.action = action;\n        this.messageID = getNextMessageID();\n    }\n}\n\nexport class InitMessage extends BaseRequestMessage\n{\n    static readonly action: string = 'init';\n    readonly wasmModuleName: string;\n    readonly licenseKey: string;\n    readonly userId: string;\n    readonly registerLoadCallback: boolean;\n    readonly allowHelloMessage: boolean;\n\n    constructor( wasmLoadSettings: WasmSDKLoadSettings, userId: string )\n    {\n        super( InitMessage.action );\n        this.wasmModuleName = wasmLoadSettings.wasmModuleName;\n        this.licenseKey = wasmLoadSettings.licenseKey;\n        this.userId = userId;\n        this.registerLoadCallback = wasmLoadSettings.loadProgressCallback != null;\n        this.allowHelloMessage = wasmLoadSettings.allowHelloMessage;\n    }\n};\n\nexport enum ParameterType\n{\n    Any,\n    Recognizer\n}\n\nexport interface WrappedParameter\n{\n    parameter: any;\n    type: ParameterType;\n}\n\nexport class InvokeFunction extends BaseRequestMessage\n{\n    static readonly action: string = 'invokeFunction';\n    readonly funcName: string;\n    readonly params: Array< WrappedParameter >;\n\n    constructor( funcName: string, params: Array< WrappedParameter > )\n    {\n        super( InvokeFunction.action );\n        this.funcName = funcName;\n        this.params = params;\n    }\n}\n\nexport class CreateNewRecognizer extends BaseRequestMessage\n{\n    static readonly action: string = 'createNewNativeObject';\n    readonly className: string;\n    readonly params: Array< WrappedParameter >;\n\n    constructor( className: string, params: Array< WrappedParameter > )\n    {\n        super( CreateNewRecognizer.action );\n        this.className = className;\n        this.params = params;\n    }\n}\n\nexport class CreateRecognizerRunner extends BaseRequestMessage\n{\n    static readonly action: string = 'createRecognizerRunner';\n    readonly recognizerHandles: Array< number >;\n    readonly allowMultipleResults: boolean;\n    readonly registeredMetadataCallbacks: RegisteredMetadataCallbacks;\n\n    constructor( recognizerHandles: Array< number >, allowMultipleResults: boolean, registeredMetadataCallbacks: RegisteredMetadataCallbacks )\n    {\n        super( CreateRecognizerRunner.action );\n        this.recognizerHandles = recognizerHandles;\n        this.allowMultipleResults = allowMultipleResults;\n        this.registeredMetadataCallbacks = registeredMetadataCallbacks;\n    }\n}\n\nexport class ReconfigureRecognizerRunner extends BaseRequestMessage\n{\n    static readonly action: string = 'reconfigureRecognizerRunner';\n    readonly recognizerHandles: Array< number >;\n    readonly allowMultipleResults: boolean;\n\n    constructor( recognizerHandles: Array< number >, allowMultipleResults: boolean )\n    {\n        super( ReconfigureRecognizerRunner.action );\n        this.recognizerHandles = recognizerHandles;\n        this.allowMultipleResults = allowMultipleResults;\n    }\n}\n\nexport class DeleteRecognizerRunner extends BaseRequestMessage\n{\n    static readonly action: string = 'deleteRecognizerRunner';\n\n    constructor()\n    {\n        super( DeleteRecognizerRunner.action );\n    }\n}\n\nexport class InvokeObjectMethod extends BaseRequestMessage\n{\n    static readonly action: string = 'invokeObject';\n    readonly objectHandle: number;\n    readonly methodName: string;\n    readonly params: Array< WrappedParameter >;\n\n    constructor( objectHandle: number, methodName: string, params: Array< WrappedParameter > )\n    {\n        super( InvokeObjectMethod.action );\n        this.objectHandle = objectHandle;\n        this.methodName = methodName;\n        this.params = params;\n    }\n}\n\nexport class ProcessImage extends BaseRequestMessage implements TransferrableMessage\n{\n    static readonly action: string = 'processImage';\n    readonly frame: CapturedFrame;\n\n    constructor( image: CapturedFrame )\n    {\n        super( ProcessImage.action );\n        this.frame = image;\n    }\n\n    getTransferrables(): Array< Transferable >\n    {\n        return [ this.frame.imageData.data.buffer ];\n    }\n};\n\nexport class ResetRecognizers extends BaseRequestMessage\n{\n    static readonly action: string = 'resetRecognizers';\n    readonly hardReset: boolean\n\n    constructor( hardReset: boolean )\n    {\n        super( ResetRecognizers.action );\n        this.hardReset = hardReset;\n    }\n}\n\nexport class RegisteredMetadataCallbacks\n{\n    onDebugText:       boolean = false;\n    onDetectionFailed: boolean = false;\n    onQuadDetection:   boolean = false;\n    onPointsDetection: boolean = false;\n    onFirstSideResult: boolean = false;\n    onGlare:           boolean = false;\n}\n\nexport class RegisterMetadataCallbacks extends BaseRequestMessage\n{\n    static readonly action: string  = 'registerMetadataCallbacks';\n    readonly registeredMetadataCallbacks: RegisteredMetadataCallbacks;\n\n    constructor( registeredMetadataCallbacks: RegisteredMetadataCallbacks )\n    {\n        super( RegisterMetadataCallbacks.action );\n        this.registeredMetadataCallbacks = registeredMetadataCallbacks;\n    }\n}\n\nexport class SetDetectionOnly extends BaseRequestMessage\n{\n    static readonly action: string = 'setDetectionOnly';\n    readonly detectionOnlyMode: boolean\n\n    constructor( detectionOnlyMode: boolean )\n    {\n        super( SetDetectionOnly.action );\n        this.detectionOnlyMode = detectionOnlyMode;\n    }\n}\n\nexport class SetClearTimeoutCallback extends BaseRequestMessage\n{\n    static readonly action: string = 'setClearTimeoutCallback'\n    readonly callbackNonEmpty: boolean\n\n    constructor( callbackNonEmpty: boolean )\n    {\n        super( SetClearTimeoutCallback.action );\n        this.callbackNonEmpty = callbackNonEmpty;\n    }\n}\n\nexport class SetCameraPreviewMirrored extends BaseRequestMessage\n{\n    static readonly action: string = 'setCameraPreviewMirrored';\n    readonly cameraPreviewMirrored: boolean\n\n    constructor( cameraPreviewMirrored: boolean )\n    {\n        super( SetCameraPreviewMirrored.action );\n        this.cameraPreviewMirrored = cameraPreviewMirrored;\n    }\n}\n\n//////////////////////////////////////////\n// Response messages\n//////////////////////////////////////////\n\nexport interface ResponseMessage\n{\n    readonly messageID: number;\n}\n\nexport class StatusMessage implements ResponseMessage\n{\n    readonly messageID: number;\n    readonly success: boolean = true;\n    readonly error: string | null = null;\n\n    constructor( msgID: number, success: boolean, error: string | null )\n    {\n        this.messageID = msgID;\n        this.success = success;\n        this.error = error;\n    }\n}\n\nexport class InvokeResultMessage extends StatusMessage\n{\n    readonly result: any;\n\n    constructor( msgID: number, result: any )\n    {\n        super( msgID, true, null );\n        this.result = result;\n    }\n}\n\nexport class ObjectCreatedMessage extends StatusMessage\n{\n    readonly objectHandle: number;\n\n    constructor( msgID: number, handle: number )\n    {\n        super( msgID, true, null );\n        this.objectHandle = handle;\n    }\n}\n\nexport class ImageProcessResultMessage extends StatusMessage\n{\n    readonly recognitionState: number;\n\n    constructor( msgID: number, recognitionState: number )\n    {\n        super( msgID, true, null );\n        this.recognitionState = recognitionState;\n    }\n}\n\n//////////////////////////////////////////\n// Load progress messages\n//////////////////////////////////////////\n\nexport class LoadProgressMessage\n{\n    readonly isLoadProgressMessage = true;\n    readonly progress: number;\n\n    constructor( progress: number )\n    {\n        this.progress = progress;\n    }\n}\n\n\n//////////////////////////////////////////\n// Metadata callback messages\n//////////////////////////////////////////\n\nexport enum MetadataCallback\n{\n    onDebugText,\n    onDetectionFailed,\n    onQuadDetection,\n    onPointsDetection,\n    onFirstSideResult,\n    clearTimeoutCallback,\n    onGlare\n}\n\nexport class InvokeCallbackMessage\n{\n    readonly isCallbackMessage: boolean = true;\n    readonly callbackType:      MetadataCallback;\n    readonly callbackParameters: any[];\n\n    constructor( callbackType: MetadataCallback, callbackParams: any[] )\n    {\n        this.callbackType       = callbackType;\n        this.callbackParameters = callbackParams;\n    }\n}\n","import { CapturedFrame } from \"./FrameCapture\"\nimport { MetadataCallbacks } from \"./MetadataCallbacks\"\nimport { ClearTimeoutCallback } from \"./ClearTimeoutCallback\"\n\n////////////////////////////////////////////////\n// DATA STRUCTURES\n////////////////////////////////////////////////\n\n/**\n * Specifies the orientation of the contents of the image.\n * This is important for some recognizers, especially when\n * performing recognition on the mobile device.\n */\nexport enum ImageOrientation\n{\n    /**\n     * Image contents are rotated 90 degrees left.\n     * This usually happens on mobile devices when capturing image while\n     * device is held in \"portrait\" orientation, while device camera sensor\n     * is mounted horizontally (i.e. produced image is in \"landscape\" orienation).\n     */\n    RotatedLeft90 = 0,\n\n    /**\n     * Image contents are not rotated in any manner.\n     * This is the default for images captured using HTML canvas, as\n     * used in FrameCapture class.\n     * This orientation also usually happens on mobile devices when capturing\n     * image while device is held in \"landscape\" orientation, while device\n     * camera sensor is mounted horizontally (i.e. also in same orientation).\n     */\n    NoRotation,\n\n    /**\n     * Image contents are rotated 90 degrees right.\n     * This usually happens on mobile devices when capturing image while\n     * device is held in \"reverse-portrait\" orientation, while device camera sensor\n     * is mounted horizontally (i.e. produced image is in \"landscape\" orienation).\n     */\n    RotatedRight90,\n\n    /**\n     * Image contents are rotated 180 degrees, i.e. image contents are \"upside down\".\n     * This usually happens on mobile devices when capturing image while\n     * device is held in \"reverse-landscape\" orientation, while device camera sensor\n     * is mounted horizontally (i.e. produced image is in \"landscape\" orienation).\n     */\n    Rotated180\n};\n\n/**\n * Specifies the state of the recognition result.\n */\nexport enum RecognizerResultState\n{\n    /** Nothing has been recognized. */\n    Empty = 0,\n    /** Something has been recognized, but some mandatory data is still missing. */\n    Uncertain,\n    /** All required data has been recognized. */\n    Valid\n};\n\n/**\n * Specifies an abstract object placed on the WebAssembly heap.\n * Objects placed on the WebAssembly heap are not cleaned up by the\n * garbage collector of the JavaScript engine. The memory used by\n * the object must be cleaned up manually by calling the delete() method.\n */\nexport interface WasmNativeObject\n{\n    /**\n     * Cleans up the object from the WebAssembly heap.\n     */\n    delete(): Promise< void >;\n};\n\n/**\n * Specifies the abstract recognition result.\n */\nexport interface RecognizerResult\n{\n    /** State of the recognition result. See the documentation for RecognizerResultState for more information. */\n    readonly state: RecognizerResultState;\n};\n\n/**\n * Specifies the abstract settings for the Recognizer object.\n */\nexport interface RecognizerSettings\n{}\n\n/**\n * Specifies an abstract Recognizer object. The Recognizer object is the basic unit of processing.\n */\nexport interface Recognizer extends WasmNativeObject\n{\n    /**\n     * Name of this recognizer.\n     */\n    readonly recognizerName: string;\n\n    /**\n     * Returns the currently applied settings to the specific recognizer.\n     */\n    currentSettings(): Promise< RecognizerSettings >;\n\n    /**\n     * Applies the new settings to the specific recognizer.\n     * Note: if the recognizer is associated with RecognizerRunner, this method will fail.\n     * @param newSettings New settings to be applied to the recognizer.\n     */\n    updateSettings( newSettings: RecognizerSettings ): Promise< void >;\n\n    /**\n     * Returns the current result of the recognition.\n     */\n    getResult(): Promise< RecognizerResult >;\n}\n\n/**\n * Specifies a main Recognizer orchestrator object.\n */\nexport interface RecognizerRunner extends WasmNativeObject\n{\n    /**\n     * Starts the recognition of the given image using recognizer objects currently associated\n     * with the RecognizerRunner.\n     * @param image Image to be processed.\n     * @returns Promise that will resolve when image processing finishes.\n     */\n    processImage( image: CapturedFrame ): Promise< RecognizerResultState >;\n\n    /**\n     * Reconfigures the instance of RecognizerRunner with new recognizers. The currently associated\n     * recognizer objects are un-associated from this RecognizerRunner and are elligible for calling\n     * the updateSettings() method on them after that.\n     * @param recognizers Array of recognizer objects that should be associated with the RecognizerRunner.\n     * @param allowMultipleResults Whether or not it is allowed to return multiple results from single image. See README.md for more details about this option.\n     */\n    reconfigureRecognizers( recognizers: Array< Recognizer >, allowMultipleResults: boolean ): Promise< void >;\n\n    /**\n     * Sets the new callbacks for obtaining recognition event. Make sure you call this method while image processing is\n     * not in progress, otherwise you will have undefined behaviour.\n     * @param metadataCallbacks Callback functions that will be called when certain recognition events occur.\n     *\n     * For more information, check the documentation of MetadataCallbacks class.\n     */\n    setMetadataCallbacks( metadataCallbacks: MetadataCallbacks ): Promise< void >;\n\n    /**\n     * Resets the state of all recognizers in current recognition chain, i.e. deletes the cached data from multiple recognitions.\n     * @param hardReset If set to false, combined recognizers will not be reset. If set to true, all recognizers will be reset.\n     */\n    resetRecognizers( hardReset: boolean ): Promise< void >;\n\n    /**\n     * If enabled, recognizers will be instructed to only perform object detection, but not the entire\n     * recognition process. This is useful for testing your implementations of MetadataCallbacks without\n     * the need for the entire process to complete. Also, VideoRecognizers sets this to true only if in\n     * DetectionTest mode of video recognition.\n     * @param detectionOnly Should recognizers perform only object detection.\n     */\n    setDetectionOnlyMode( detectionOnly: boolean ): Promise< void >;\n\n    /**\n     * Sets or removes the ClearTimeoutCallback.\n     */\n    setClearTimeoutCallback( clearTimeoutCallback: ClearTimeoutCallback | null ): Promise< void >;\n\n    /**\n     * Sets whether camera preview displaying the image being recognized is being mirrored horizontally.\n     * If enabled, coordinates returned via metadatacallbacks will be adjusted accordingly due to the\n     * image being processed being different of image being displayed.\n     * The camera preview is usually mirrored when using front-facing camera.\n     * @param mirrored Whether or not metadatacallbacks should adjust coordinates for mirrored image.\n     */\n    setCameraPreviewMirrored( mirrored: boolean ): Promise< void >;\n};\n\n/**\n * @hidden\n * A proxy object for accessing the WebAssembly module.\n * Only for internal use. It's API may change in the future without any notice.\n * Please do not invoke methods directly on the instance of this interface.\n */\nexport interface WasmModuleProxy\n{\n    createRecognizerRunner( recognizers: Array< Recognizer >, allowMultipleResults: boolean, metadataCallbacks: MetadataCallbacks ): Promise< RecognizerRunner >;\n    newRecognizer( className: string, ...constructorArgs: any[] ): Promise< Recognizer >;\n};\n\n/**\n * Specifies a main object that is used for communication with the WebAssembly module.\n * This object is usually given as a parameter to functions that interop with the WebAssembly module.\n * You can obtain an instance of this object after a promise from MicroblinkSDK.loadWasmModule is successfully\n * resolved.\n */\nexport interface WasmSDK\n{\n    /**\n     * @hidden\n     * A proxy object to the WebAssmebly module.\n     * Only for internal use. It's API may change in the future without any notice.\n     */\n    readonly mbWasmModule: WasmModuleProxy;\n}\n\n/**\n * Specifies a date object, as parsed from some documents.\n * Unlike JavaScript Date object, it does not depend on time zone.\n */\nexport interface MBDate\n{\n    /** Day in month. */\n    readonly day: number;\n\n    /** Month in year. */\n    readonly month: number;\n\n    /** Year */\n    readonly year: number;\n\n    /** Original string on the document from which date was parsed. */\n    readonly originalString: string;\n\n    /** Indicates whether date was parsed successfully. */\n    readonly successfullyParsed: boolean;\n\n    /** Indicates whether object is empty. Note that it is possible to successfully parse an empty date. */\n    readonly empty: boolean;\n}\n\n/**\n * Specifies a digital signature of the specific recognizer result.\n */\nexport interface DigitalSignature\n{\n    /** Version of the digital signature. */\n    readonly version: number;\n\n    /** The digital signature of the recognition results. */\n    readonly signature: Uint8Array;\n}\n\nexport interface DigitalSignatureOptions\n{\n    /**\n     * Whether or not recognition result should be signed.\n     */\n    allowSignature: boolean\n}\n","/**\n * Interface representing possible events that can occur during image processing.\n * All functions in this interface are optional and will be called only if they are\n * implemented.\n */\nexport interface MetadataCallbacks\n{\n    /**\n     * Called when recognition process wants to display some debug text information.\n     * @param debugTest Debug text information to be displayed.\n     */\n    onDebugText?( debugTest: string ): void\n\n    /**\n     * Called when all recognizers in RecognizerRunner have failed to detect anything on the image.\n     */\n    onDetectionFailed?(): void\n\n    /**\n     * Called when recognition process wants to display some quadrilateral.\n     * @param quad Quadrilateral to be displayed.\n     */\n    onQuadDetection?( quad: DisplayableQuad ): void\n\n    /**\n     * Called when recognition process wants to display some points.\n     * @param pointSet Points to be displayed.\n     */\n    onPointsDetection?( pointSet: DisplayablePoints ): void\n\n    /**\n     * Called when first side recognition with the combined recognizer completes.\n     */\n    onFirstSideResult?(): void\n\n    /**\n     * Called when glare detection has completed with result whether glare has been found or not.\n     * @param hasGlare indicates whether glare has been found on the input image or not\n     */\n    onGlare?( hasGlare: boolean ): void;\n}\n\n/**\n * Detection status of the specific detected object.\n */\nexport enum DetectionStatus\n{\n    /** Detection failed, form not detected */\n    Fail = 0,\n    /** Object was successfully detected */\n    Success,\n    /** Object detected, but the camera is too far above it */\n    CameraTooHigh,\n    /** Fallback detection of an object was successful */\n    FallbackSuccess,\n    /** Object is detected, but parts of it are not in image */\n    Partial,\n    /** Object detected, but camera is at too big angle */\n    CameraAtAngle,\n    /** Object detected, but the camera is too near to it */\n    CameraTooNear,\n    /** Document detected, but document is too close to the edge of the frame */\n    DocumentTooCloseToEdge\n};\n\n/**\n * Interface representing any displayable object.\n */\nexport interface Displayable\n{\n    /** Detection status of the displayable object. */\n    detectionStatus: DetectionStatus\n\n    /**\n     * 3x3 transformation matrix from the image's coordinate system to view's coordinate system.\n     */\n    transformMatrix: Float32Array\n}\n\n/**\n * Interface representing a point in image.\n */\nexport interface Point\n{\n    /** X-coordinate of the point */\n    x: number\n    /** Y-coordinate of the point */\n    y: number\n}\n\n/**\n * Interface representing quadrilateral in image.\n */\nexport interface DisplayableQuad extends Displayable\n{\n    /** Top-left point of the quadrilateral */\n    topLeft: Point\n    /** Top-right point of the quadrilateral */\n    topRight: Point\n    /** Bottom-left point of the quadrilateral */\n    bottomLeft: Point\n    /** Bottom-right point of the quadrilateral */\n    bottomRight: Point\n}\n\n/**\n * Interface representing list of points in image.\n */\nexport interface DisplayablePoints extends Displayable\n{\n    /** Array of points */\n    points: Point[]\n}\n","import * as Messages from \"./Messages\"\nimport { CapturedFrame } from \"../FrameCapture\";\nimport\n{\n    RecognizerResultState,\n    RecognizerRunner,\n    WasmModuleProxy,\n    WasmSDK,\n    Recognizer,\n    RecognizerSettings,\n    RecognizerResult} from \"../DataStructures.js\"\nimport { ClearTimeoutCallback } from \"../ClearTimeoutCallback\";\nimport { MetadataCallbacks, DisplayablePoints, DisplayableQuad } from \"../MetadataCallbacks\"\nimport { WasmSDKLoadSettings, OptionalLoadProgressCallback } from \"../WasmLoadSettings\";\n\n\n////////////////////////////////////////////////\n// Web Worker Proxy implementation\n////////////////////////////////////////////////\n\ninterface EventHandler\n{\n    ( msg: Messages.ResponseMessage ): void;\n}\n\nfunction defaultEventHandler( resolve: any, reject: any )\n{\n    return ( msg: Messages.ResponseMessage ) =>\n    {\n        const resultMsg = msg as Messages.StatusMessage;\n        if ( resultMsg.success )\n        {\n            resolve();\n        }\n        else\n        {\n            reject( resultMsg.error );\n        }\n    }\n}\n\nfunction defaultResultEventHandler( successResolver: EventHandler, reject: any )\n{\n    return ( msg: Messages.ResponseMessage ) =>\n    {\n        const resultMsg = msg as Messages.StatusMessage;\n        if ( resultMsg.success )\n        {\n            successResolver( msg );\n        }\n        else\n        {\n            reject( resultMsg.error );\n        }\n    }\n}\n\nfunction wrapParameters( params: Array< any > ): Array< Messages.WrappedParameter >\n{\n    // convert params\n    const wrappedPrameters = [];\n    for ( let i in params )\n    {\n        let param = params[ i ];\n        let paramType = Messages.ParameterType.Any;\n        if ( param instanceof RemoteRecognizer )\n        {\n            paramType = Messages.ParameterType.Recognizer;\n            param = param.getRemoteObjectHandle();\n        }\n        wrappedPrameters.push( { parameter: param, type: paramType } );\n    }\n    return wrappedPrameters;\n}\n\nexport class RemoteRecognizer implements Recognizer\n{\n    private readonly wasmSDKWorker : WasmSDKWorker;\n    private          objectHandle  : number;\n            readonly recognizerName: string;\n\n    constructor( wasmWorker: WasmSDKWorker, recognizerName: string, remoteObjHandle: number )\n    {\n        this.wasmSDKWorker = wasmWorker;\n        this.objectHandle = remoteObjHandle;\n        this.recognizerName = recognizerName;\n    }\n\n    getRemoteObjectHandle()\n    {\n        return this.objectHandle;\n    }\n\n    currentSettings(): Promise< RecognizerSettings >\n    {\n        if ( this.objectHandle < 0 )\n        {\n            return Promise.reject( \"Invalid object handle: \" + this.objectHandle );\n        }\n        return new Promise< RecognizerSettings >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.InvokeObjectMethod( this.objectHandle, \"currentSettings\", [] );\n                const handler = defaultResultEventHandler\n                (\n                    ( msg: Messages.ResponseMessage ) =>\n                    {\n                        resolve( ( msg as Messages.InvokeResultMessage ).result );\n                    },\n                    reject\n                );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n\n    updateSettings( newSettings: RecognizerSettings ): Promise< void >\n    {\n        if ( this.objectHandle < 0 )\n        {\n            return Promise.reject( \"Invalid object handle: \" + this.objectHandle );\n        }\n        return new Promise< void >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.InvokeObjectMethod( this.objectHandle, \"updateSettings\", [ { parameter: newSettings, type: Messages.ParameterType.Any } ] );\n                const handler = defaultEventHandler( resolve, reject );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n\n    getResult(): Promise< RecognizerResult >\n    {\n        if ( this.objectHandle < 0 )\n        {\n            return Promise.reject( \"Invalid object handle: \" + this.objectHandle );\n        }\n        return new Promise< RecognizerResult >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.InvokeObjectMethod( this.objectHandle, \"getResult\", [] );\n                const handler = defaultResultEventHandler\n                (\n                    ( msg: Messages.ResponseMessage ) =>\n                    {\n                        resolve( ( msg as Messages.InvokeResultMessage ).result );\n                    },\n                    reject\n                );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n\n    delete(): Promise< void >\n    {\n        if ( this.objectHandle < 0 )\n        {\n            return Promise.reject( \"Invalid object handle: \" + this.objectHandle );\n        }\n        return new Promise< void >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.InvokeObjectMethod( this.objectHandle, \"delete\", [] );\n                const handler = defaultEventHandler\n                (\n                    () =>\n                    {\n                        this.objectHandle = -1;\n                        resolve();\n                    },\n                    reject\n                );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n\n};\n\nfunction createRegisteredCallbacks( metadataCallbacks: MetadataCallbacks )\n{\n    const msg = new Messages.RegisteredMetadataCallbacks();\n\n    // https://stackoverflow.com/a/20093686/213057\n    msg.onDebugText       = !!metadataCallbacks.onDebugText;\n    msg.onDetectionFailed = !!metadataCallbacks.onDetectionFailed;\n    msg.onPointsDetection = !!metadataCallbacks.onPointsDetection;\n    msg.onQuadDetection   = !!metadataCallbacks.onQuadDetection;\n    msg.onFirstSideResult = !!metadataCallbacks.onFirstSideResult;\n    msg.onGlare           = !!metadataCallbacks.onGlare;\n    return msg;\n}\n\nclass RemoteRecognizerRunner implements RecognizerRunner\n{\n    private readonly wasmSDKWorker: WasmSDKWorker;\n    private deleted = false;\n\n    constructor( wasmWorker: WasmSDKWorker )\n    {\n        this.wasmSDKWorker = wasmWorker;\n    }\n\n    processImage( image: CapturedFrame ): Promise< RecognizerResultState >\n    {\n        if ( this.deleted )\n        {\n            return Promise.reject( \"Recognizer runner is deleted. It cannot be used anymore!\" );\n        }\n        return new Promise< RecognizerResultState >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.ProcessImage( image );\n                const handler = defaultResultEventHandler\n                (\n                    ( response: Messages.ResponseMessage ) =>\n                    {\n                        const state: RecognizerResultState = ( response as Messages.ImageProcessResultMessage ).recognitionState;\n                        resolve( state );\n                    },\n                    reject\n                );\n                this.wasmSDKWorker.postTransferrableMessage( msg, handler );\n            }\n        );\n    }\n\n    reconfigureRecognizers( recognizers: Array< Recognizer >, allowMultipleResults: boolean ): Promise< void >\n    {\n        if ( this.deleted )\n        {\n            return Promise.reject( \"Recognizer runner is deleted. It cannot be used anymore!\" );\n        }\n        return new Promise< void >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const recognizerHandles = getRecognizerHandles( recognizers as Array< RemoteRecognizer > );\n                const msg = new Messages.ReconfigureRecognizerRunner( recognizerHandles, allowMultipleResults );\n                const handler = defaultEventHandler( resolve, reject );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n\n    setMetadataCallbacks( metadataCallbacks: MetadataCallbacks ): Promise< void >\n    {\n        return new Promise< void >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.RegisterMetadataCallbacks( createRegisteredCallbacks( metadataCallbacks ) );\n                const handler = defaultEventHandler( resolve, reject );\n                this.wasmSDKWorker.postMessageAndRegisterCallbacks( msg, metadataCallbacks, handler );\n            }\n        );\n    }\n\n    resetRecognizers( hardReset: boolean ): Promise< void >\n    {\n        return new Promise< void >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.ResetRecognizers( hardReset );\n                const handler = defaultEventHandler( resolve, reject );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n\n    setDetectionOnlyMode( detectionOnly: boolean ): Promise< void >\n    {\n        return new Promise< void >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.SetDetectionOnly( detectionOnly );\n                const handler = defaultEventHandler( resolve, reject );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n\n    setClearTimeoutCallback( clearTimeoutCallback: ClearTimeoutCallback | null ): Promise< void >\n    {\n        return new Promise< void >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.SetClearTimeoutCallback( clearTimeoutCallback != null );\n                const handler = defaultEventHandler( resolve, reject );\n                this.wasmSDKWorker.registerClearTimeoutCallback( clearTimeoutCallback );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        )\n    }\n\n    setCameraPreviewMirrored( mirrored: boolean ): Promise< void >\n    {\n        return new Promise< void >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.SetCameraPreviewMirrored( mirrored );\n                const handler = defaultEventHandler( resolve, reject );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n\n    delete(): Promise< void >\n    {\n        if ( this.deleted )\n        {\n            return Promise.reject( \"Recognizer runner is already deleted.\" );\n        }\n        return new Promise< void >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.DeleteRecognizerRunner();\n                const handler = defaultEventHandler\n                (\n                    () =>\n                    {\n                        this.deleted = true;\n                        resolve();\n                    },\n                    reject\n                );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n};\n\nfunction getRecognizerHandles( remoteRecognizers: Array< RemoteRecognizer > )\n{\n    const recognizerHandles: Array< number > = [];\n    for ( let recognizerIndex in remoteRecognizers )\n    {\n        const remoteRecognizer = remoteRecognizers[ recognizerIndex ];\n        recognizerHandles.push( remoteRecognizer.getRemoteObjectHandle() );\n    }\n    return recognizerHandles;\n}\n\nclass WasmModuleWorkerProxy implements WasmModuleProxy\n{\n    private readonly wasmSDKWorker: WasmSDKWorker;\n\n    constructor( wasmSDKWorker: WasmSDKWorker )\n    {\n        this.wasmSDKWorker = wasmSDKWorker;\n    }\n\n    createRecognizerRunner( recognizers: Array< Recognizer >, allowMultipleResults: boolean = false, metadataCallbacks: MetadataCallbacks = {} ): Promise< RecognizerRunner >\n    {\n        return new Promise< RecognizerRunner >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const recognizerHandles = getRecognizerHandles( recognizers as Array< RemoteRecognizer > );\n                const msg = new Messages.CreateRecognizerRunner( recognizerHandles, allowMultipleResults, createRegisteredCallbacks( metadataCallbacks ) );\n                const handler = defaultEventHandler\n                (\n                    () =>\n                    {\n                        resolve( new RemoteRecognizerRunner( this.wasmSDKWorker ) );\n                    },\n                    reject\n                );\n                this.wasmSDKWorker.postMessageAndRegisterCallbacks( msg, metadataCallbacks, handler );\n            }\n        );\n    }\n\n    newRecognizer( className: string, ...constructorArgs: any[] ): Promise< Recognizer >\n    {\n        return new Promise< Recognizer >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const msg = new Messages.CreateNewRecognizer( className, wrapParameters( constructorArgs ) );\n                const handler = defaultResultEventHandler\n                (\n                    ( msg: Messages.ResponseMessage ) =>\n                    {\n                        resolve( new RemoteRecognizer( this.wasmSDKWorker, className, ( msg as Messages.ObjectCreatedMessage ).objectHandle ) );\n                    },\n                    reject\n                );\n                this.wasmSDKWorker.postMessage( msg, handler );\n            }\n        );\n    }\n}\n\nexport class WasmSDKWorker implements WasmSDK\n{\n    readonly mbWasmModule: WasmModuleWorkerProxy;\n\n    private readonly mbWasmWorker: Worker;\n    private eventHandlers: { [ key: number ] : EventHandler } = {};\n    private metadataCallbacks: MetadataCallbacks = {};\n    private loadCallback: OptionalLoadProgressCallback;\n    private clearTimeoutCallback: ClearTimeoutCallback | null = null;\n\n    private constructor( worker: Worker, loadProgressCallback: OptionalLoadProgressCallback )\n    {\n        this.mbWasmWorker = worker;\n        this.mbWasmWorker.onmessage = ( event: MessageEvent ) => { this.handleWorkerEvent( event ); };\n        this.mbWasmModule = new WasmModuleWorkerProxy( this );\n        this.loadCallback = loadProgressCallback;\n    }\n\n    postMessage( message: Messages.RequestMessage, eventHandler: EventHandler )\n    {\n        this.eventHandlers[ message.messageID ] = eventHandler;\n        this.mbWasmWorker.postMessage( message );\n    }\n\n    postTransferrableMessage( message: Messages.RequestMessage & Messages.TransferrableMessage, eventHandler: EventHandler )\n    {\n        this.eventHandlers[ message.messageID ] = eventHandler;\n        this.mbWasmWorker.postMessage( message, message.getTransferrables() );\n    }\n\n    postMessageAndRegisterCallbacks( message: Messages.RequestMessage, metadataCallbacks: MetadataCallbacks, eventHandler: EventHandler )\n    {\n        this.eventHandlers[ message.messageID ] = eventHandler;\n        this.metadataCallbacks = metadataCallbacks;\n        this.mbWasmWorker.postMessage( message );\n    }\n\n    registerClearTimeoutCallback( callback: ClearTimeoutCallback | null )\n    {\n        this.clearTimeoutCallback = callback;\n    }\n\n    private handleWorkerEvent( event: MessageEvent )\n    {\n        if ( 'isCallbackMessage' in event.data )\n        {\n            const msg = event.data as Messages.InvokeCallbackMessage;\n            switch ( msg.callbackType )\n            {\n                case Messages.MetadataCallback.onDebugText:\n                    this.metadataCallbacks.onDebugText!( msg.callbackParameters[ 0 ] as string );\n                    break;\n                case Messages.MetadataCallback.onDetectionFailed:\n                    this.metadataCallbacks.onDetectionFailed!();\n                    break;\n                case Messages.MetadataCallback.onPointsDetection:\n                    this.metadataCallbacks.onPointsDetection!( msg.callbackParameters[ 0 ] as DisplayablePoints );\n                    break;\n                case Messages.MetadataCallback.onQuadDetection:\n                    this.metadataCallbacks.onQuadDetection!( msg.callbackParameters[ 0 ] as DisplayableQuad );\n                    break;\n                case Messages.MetadataCallback.onFirstSideResult:\n                    this.metadataCallbacks.onFirstSideResult!();\n                    break;\n                case Messages.MetadataCallback.clearTimeoutCallback:\n                    this.clearTimeoutCallback!.onClearTimeout();\n                    break;\n                case Messages.MetadataCallback.onGlare:\n                    this.metadataCallbacks.onGlare!( msg.callbackParameters[ 0 ] as boolean );\n                    break;\n                default:\n                    throw new Error( \"Unknown callback type \" + msg.callbackType );\n            }\n        }\n        else if ( 'isLoadProgressMessage' in event.data )\n        {\n            const msg = event.data as Messages.LoadProgressMessage;\n            this.loadCallback!( msg.progress );\n        }\n        else\n        {\n            const msg = event.data as Messages.ResponseMessage;\n            const eventHandler = this.eventHandlers[ msg.messageID ];\n            delete this.eventHandlers[ msg.messageID ];\n            eventHandler( msg );\n        }\n    }\n\n    static async createWasmWorker( worker: Worker, wasmLoadSettings: WasmSDKLoadSettings, userId: string ): Promise< WasmSDKWorker >\n    {\n        return new Promise< WasmSDKWorker >\n        (\n            ( resolve: any, reject: any ) =>\n            {\n                const wasmWorker = new WasmSDKWorker( worker, wasmLoadSettings.loadProgressCallback );\n                const initMessage = new Messages.InitMessage( wasmLoadSettings, userId );\n                const initEventHandler = defaultEventHandler\n                (\n                    () =>\n                    {\n                        resolve( wasmWorker );\n                    },\n                    reject\n                );\n                wasmWorker.postMessage( initMessage, initEventHandler );\n            }\n        );\n    }\n}\n","import { ImageOrientation } from \"./DataStructures\";\n\n////////////////////////////////////////////////\n// Frame capture and camera management support\n////////////////////////////////////////////////\n\nlet canvas : HTMLCanvasElement;\n\n/**\n * Represents a captured frame from HTMLVideoElement.\n */\nexport class CapturedFrame\n{\n    /** Instance of ImageData object - contains pixels and metadata about the captured image. */\n    readonly imageData: ImageData;\n\n    /** Orientation of the captured frame */\n    readonly orientation: ImageOrientation;\n\n    /** Indicates whether captured frame originated from still image or video stream. */\n    readonly videoFrame: boolean;\n\n    constructor( imageData: ImageData, orientation: ImageOrientation, videoFrame: boolean )\n    {\n        this.imageData = imageData;\n        this.orientation = orientation;\n        this.videoFrame = videoFrame;\n    }\n}\n\n/**\n * Captures a frame from any CanvasImageSource, such as HTMLVideoElement or HTMLImageElement.\n * @param imageSource image source from which frame should be captured\n * @returns instance of CapturedFrame\n */\nexport function captureFrame( imageSource: CanvasImageSource )\n{\n    let imageWidth: number\n    let imageHeight: number\n    let videoFrame = false;\n    if ( imageSource instanceof HTMLVideoElement )\n    {\n        imageWidth = imageSource.videoWidth;\n        imageHeight = imageSource.videoHeight;\n        videoFrame = true;\n    }\n    else if ( imageSource instanceof HTMLImageElement )\n    {\n        imageWidth = imageSource.naturalWidth;\n        imageHeight = imageSource.naturalHeight;\n    }\n    else if ( imageSource instanceof SVGImageElement )\n    {\n        throw new Error( \"Recognition of SVG elements not supported!\" );\n    }\n    else\n    {\n        imageWidth = imageSource.width;\n        imageHeight = imageSource.height;\n    }\n\n    canvas = canvas || document.createElement( 'canvas' ) as HTMLCanvasElement;\n    canvas.width = imageWidth;\n    canvas.height = imageHeight;\n    const ctx = canvas.getContext( '2d' )!;\n    ctx.drawImage( imageSource, 0, 0, canvas.width, canvas.height );\n    let pixelData = ctx.getImageData( 0, 0, canvas.width, canvas.height );\n    return new CapturedFrame\n    (\n        pixelData,\n        ImageOrientation.NoRotation, // TODO: https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation or https://developer.mozilla.org/en-US/docs/Web/API/Window/orientation\n        videoFrame\n    );\n}\n","import\n{\n    RecognizerRunner,\n    RecognizerResultState\n} from './DataStructures'\nimport { captureFrame } from './FrameCapture'\n\n/**\n * Preferred type of camera to be used when opening the camera feed.\n */\nexport enum PreferredCameraType\n{\n    /** Prefer back facing camera */\n    BackFacingCamera,\n    /** Prefer front facing camera */\n    FrontFacingCamera\n}\n\n/**\n * Explanation why VideoRecognizer has failed to open the camera feed.\n */\nexport enum NotSupportedReason\n{\n    /** navigator.mediaDevices.getUserMedia is not supported by current browser for current context. */\n    MediaDevicesNotSupported = \"MediaDevicesNotSupported\",\n    /** Camera with requested features is not available on current device. */\n    CameraNotFound = \"CameraNotFound\",\n    /** Camera access was not granted by the user. */\n    CameraNotAllowed = \"CameraNotAllowed\",\n    /** Unable to start playing because camera is already in use. */\n    CameraInUse = \"CameraInUse\",\n    /** Camera is currently not available due to a OS or hardware error. */\n    CameraNotAvailable = \"CameraNotAvailable\"\n};\n\n/**\n * The error object thrown when VideoRecognizer fails to open the camera feed.\n */\nexport class VideoRecognizerError extends Error\n{\n    /** The reason why opening the camera failed. */\n    readonly reason: NotSupportedReason;\n\n    constructor( reason: NotSupportedReason, ...params: any[] )\n    {\n        super( ...params );\n        this.reason = reason;\n        this.name = \"VideoRecognizerError\";\n    }\n}\n\n/**\n * Indicates mode of recognition in VideoRecognizer.\n */\nexport enum VideoRecognitionMode\n{\n    /** Normal recognition */\n    Recognition,\n    /** Will perform indefinite scan. Useful for profiling the performance of scan (using onDebugText metadata callback) */\n    RecognitionTest,\n    /** Will perform only detection. Useful for profiling the performance of detection (using onDebugText metadata callback) */\n    DetectionTest\n}\n\n/**\n * Invoked when VideoRecognizer finishes the recognition of the video stream.\n * @param recognitionState The state of recognition after finishing. If RecognizerResultState.Empty or\n *                         RecognizerResultState.Empty are returned, this indicates that the scanning\n *                         was cancelled or timeout has been reached.\n */\nexport type OnScanningDone = ( recognitionState: RecognizerResultState ) => void;\n\n/**\n * A wrapper around RecognizerRunner that can use it to perform recognition of video feeds - either from live camera or from predefined video file.\n */\nexport class VideoRecognizer\n{\n    /**\n     * Creates a new VideoRecognizer by opening a camera stream and attaching it to given HTMLVideoElement. If camera cannot be accessed,\n     * the returned promise will be rejected.\n     * @param cameraFeed HTMLVideoELement to which camera stream should be attached\n     * @param recognizerRunner RecognizerRunner that should be used for video stream recognition.\n     * @param preferredCameraType Whether back facing or front facing camera is preferred. Obeyed only if there is a choice (i.e. if device has only front-facing camera, the opened camera will be a front-facing camera, regardless of preference)\n     */\n    static async createVideoRecognizerFromCameraStream( cameraFeed: HTMLVideoElement, recognizerRunner: RecognizerRunner, preferredCameraType: PreferredCameraType = PreferredCameraType.BackFacingCamera ): Promise< VideoRecognizer >\n    {\n        return new Promise< VideoRecognizer >\n        (\n            async ( resolve: any, reject: any ) =>\n            {\n                if ( navigator.mediaDevices && navigator.mediaDevices.getUserMedia )\n                {\n                    try\n                    {\n                        const selectedCamera = await selectCamera( preferredCameraType );\n                        if ( selectedCamera == null )\n                        {\n                            reject( new VideoRecognizerError( NotSupportedReason.CameraNotFound ) );\n                            return;\n                        }\n\n                        const constraints: MediaStreamConstraints =\n                        {\n                            audio: false,\n                            video:\n                            {\n                                width:\n                                {\n                                    min: 640,\n                                    ideal: 1920,\n                                    max: 1920\n                                },\n                                height:\n                                {\n                                    min: 480,\n                                    ideal: 1080,\n                                    max: 1080\n                                }\n                            }\n                        };\n                        if ( selectedCamera.deviceId === \"\" )\n                        {\n                            ( constraints.video as MediaTrackConstraints ).facingMode =\n                            {\n                                ideal: preferredCameraType === PreferredCameraType.BackFacingCamera ? \"environment\" : \"user\"\n                            }\n                        }\n                        else\n                        {\n                            ( constraints.video as MediaTrackConstraints ).deviceId =\n                            {\n                                exact: selectedCamera.deviceId\n                            }\n                        }\n\n                        const stream = await navigator.mediaDevices.getUserMedia( constraints );\n                        cameraFeed.controls = false;\n                        cameraFeed.srcObject = stream;\n                        // mirror the camera view for front-facing camera\n                        if ( selectedCamera.facing == PreferredCameraType.FrontFacingCamera )\n                        {\n                            cameraFeed.style.transform = \"scaleX(-1)\";\n                        }\n                        // TODO: await maybe not needed here\n                        await recognizerRunner.setCameraPreviewMirrored( selectedCamera.facing == PreferredCameraType.FrontFacingCamera );\n                        resolve( new VideoRecognizer( cameraFeed, recognizerRunner ) );\n                    }\n                    catch( error )\n                    {\n                        let errorReason = NotSupportedReason.CameraInUse;\n                        switch( error.name )\n                        {\n                            case 'NotFoundError':\n                            case 'OverconstrainedError':\n                                errorReason = NotSupportedReason.CameraNotFound;\n                                break;\n                            case 'NotAllowedError':\n                            case 'SecurityError':\n                                errorReason = NotSupportedReason.CameraNotAllowed;\n                                break;\n                            case 'AbortError':\n                            case 'NotReadableError':\n                                errorReason = NotSupportedReason.CameraNotAvailable;\n                                break;\n                            case 'TypeError': // this should never happen. If it does, rethrow it\n                                throw error;\n                        }\n                        reject( new VideoRecognizerError( errorReason, error.message ) );\n                    }\n                }\n                else\n                {\n                    reject( new VideoRecognizerError( NotSupportedReason.MediaDevicesNotSupported ) );\n                }\n            }\n        );\n    }\n\n    /**\n     * Creates a new VideoRecognizer by attaching the given URL to video to given HTMLVideoElement and using it to display video frames while\n     * processing them.\n     * @param videoPath URL of the video file that should be recognized.\n     * @param videoFeed HTMLVideoElement to which video file will be attached\n     * @param recognizerRunner RecognizerRunner that should be used for video stream recognition.\n     */\n    static async createVideoRecognizerFromVideoPath( videoPath: string, videoFeed: HTMLVideoElement, recognizerRunner: RecognizerRunner ): Promise< VideoRecognizer >\n    {\n        return new Promise\n        (\n            ( resolve: any ) =>\n            {\n                videoFeed.src = videoPath;\n                videoFeed.currentTime = 0;\n                videoFeed.onended = () =>\n                {\n                    videoRecognizer.cancelRecognition();\n                };\n                const videoRecognizer = new VideoRecognizer( videoFeed, recognizerRunner );\n                resolve( videoRecognizer );\n            }\n        );\n    }\n\n    /**\n     * Sets the video recognition mode to be used.\n     * @param videoRecognitionMode the video recognition mode to be used.\n     */\n    async setVideoRecognitionMode( videoRecognitionMode: VideoRecognitionMode )\n    {\n        this.videoRecognitionMode = videoRecognitionMode;\n        await this.recognizerRunner.setDetectionOnlyMode( this.videoRecognitionMode === VideoRecognitionMode.DetectionTest );\n    }\n\n    /**\n     * Starts the recognition of the video stream associated with this VideoRecognizer. The stream will be\n     * unpaused and recognition loop will start. After recognition completes, a onScanningDone callback will be invoked\n     * with state of the recognition.\n     * NOTE: As soon as the execution of the callback completes, the recognition loop will continue and recognition state\n     *       will be retained. To clear the recognition state, use resetRecognizers (within your callback). To pause the recognition\n     *       loop, use pauseRecognition (within your callback) - to resume it later use resumeRecognition. To completely stop the\n     *       recognition and video feed, while keeping the ability to use this VideoRecognizer later, use pauseVideoFeed. To\n     *       completely stop the recognition and video feed and release all the resources involved with video stream, use releaseVideoFeed.\n     * @param onScanningDone Callback that will be invoked when recognition completes.\n     * @param recognitionTimeoutMs Amount of time before returned promise will be resolved regardless of whether recognition was successful or not.\n     */\n    startRecognition( onScanningDone: OnScanningDone, recognitionTimeoutMs: number = 30000 ): void\n    {\n        if ( this.videoFeed == null )\n        {\n            throw new Error( 'The associated video feed has been released!' );\n        }\n        if ( !this.videoFeed.paused )\n        {\n            throw new Error( 'The associated video feed is not paused. Use resumeRecognition instead!' );\n        }\n\n        this.cancelled = false;\n        this.recognitionPaused = false;\n        this.clearTimeout();\n        this.recognitionTimeoutMs = recognitionTimeoutMs;\n        this.onScanningDone = onScanningDone;\n        this.recognizerRunner.setClearTimeoutCallback( { onClearTimeout: () => this.clearTimeout() } );\n        this.videoFeed.play().then\n        (\n            () => this.playPauseEvent(),\n            () =>\n            {\n                alert( \"Auto-play prevented by browser security rules! Please start video manually!\" );\n                this.videoFeed!.controls = true;\n                this.videoFeed!.addEventListener( 'play' , () => this.playPauseEvent() );\n                this.videoFeed!.addEventListener( 'pause', () => this.playPauseEvent() );\n            }\n        );\n    }\n\n    /**\n     * Performs the recognition of the video stream associated with this VideoRecognizer. The stream will be\n     * unpaused, recognition will be performed and promise will be resolved with recognition status. After\n     * the resolution of returned promise, the video stream will be paused, but not released. To release the\n     * stream, use function releaseVideoFeed.\n     * This is a simple version of startRecognition that should be used for most cases, like when you only need\n     * to perform one scan per video session.\n     * @param recognitionTimeoutMs Amount of time before returned promise will be resolved regardless of whether recognition was successful or not.\n     */\n    async recognize( recognitionTimeoutMs: number = 30000 ): Promise< RecognizerResultState >\n    {\n        return new Promise\n        (\n            ( resolve: ( recognitionStatus: RecognizerResultState ) => void, reject: any) =>\n            {\n                try\n                {\n                    this.startRecognition\n                    (\n                        ( recognitionState: RecognizerResultState ) =>\n                        {\n                            this.pauseVideoFeed();\n                            resolve( recognitionState );\n                        },\n                        recognitionTimeoutMs\n                    );\n                }\n                catch ( error )\n                {\n                    reject( error );\n                }\n            }\n        );\n    }\n\n    /**\n     * Cancels current ongoing recognition. Note that after cancelling the recognition, the callback given to\n     * startRecognition will be immediately called. This also means that the promise returned from method\n     * recognize will be resolved immediately.\n     */\n    cancelRecognition()\n    {\n        this.cancelled = true;\n    }\n\n    /**\n     * Pauses the video feed. You can resume the feed by calling recognize or startRecognition.\n     * Note that this pauses both the camera feed and recognition. If you just want to pause\n     * recognition, while keeping the camera feed active, call method pauseRecognition.\n     */\n    pauseVideoFeed()\n    {\n        this.pauseRecognition();\n        this.videoFeed!.pause();\n    }\n\n    /**\n     * Pauses the recognition. This means that video frames that arrive from given video source\n     * will not be recognized. To resume recognition, call resumeRecognition(boolean).\n     * Unlike cancelRecognition, the callback given to startRecognition will not be invoked after pausing\n     * the recognition (unless there is already processing in-flight that may call the callback just before\n     * pausing the actual recognition loop).\n     */\n    pauseRecognition()\n    {\n        this.recognitionPaused = true;\n    }\n\n    /**\n     * Convenience method for invoking resetRecognizers on associated RecognizerRunner.\n     * @param hardReset Same as in RecognizerRunner.resetRecognizers.\n     */\n    async resetRecognizers( hardReset: boolean )\n    {\n        await this.recognizerRunner.resetRecognizers( hardReset );\n    }\n\n    /**\n     * Convenience method for accessing RecognizerRunner associated with this VideoRecognizer.\n     * Sometimes it's useful to reconfigure RecognizerRunner while handling onScanningDone callback\n     * and this method makes that much more convenient.\n     */\n    getRecognizerRunner(): RecognizerRunner\n    {\n        return this.recognizerRunner;\n    }\n\n    /**\n     * Resumes the recognition. The video feed must not be paused. If it is, an error will be thrown.\n     * If video feed is paused, you should use recognize or startRecognition methods.\n     * @param resetRecognizers Indicates whether resetRecognizers should be invoked while resuming the recognition\n     */\n    resumeRecognition( resetRecognizers: boolean )\n    {\n        this.cancelled = false;\n        this.timedOut = false;\n        this.recognitionPaused = false;\n        if ( this.videoFeed!.paused )\n        {\n            throw new Error( \"Cannot resume recognition while video feed is paused! You need to use recognize or startRecognition\" );\n        }\n        setTimeout\n        (\n            async () =>\n            {\n                if ( resetRecognizers ) await this.resetRecognizers( true );\n                this.recognitionLoop();\n            },\n            1\n        );\n    }\n\n    /**\n     * Stops all media stream tracks associated with current HTMLVideoElement and removes any references to it.\n     * Note that after calling this method you can no longer use this VideoRecognizer for recognition.\n     * This method should be called after you no longer plan on performing video recognition to let browser know\n     * that it can release resources related to any media streams used.\n     */\n    releaseVideoFeed()\n    {\n        if ( this.videoFeed != null )\n        {\n            if ( this.videoFeed.srcObject != null )\n            {\n                if ( !this.videoFeed.paused ) this.cancelRecognition();\n                ( this.videoFeed.srcObject as MediaStream ).getTracks().forEach( track => track.stop() );\n                this.videoFeed.srcObject = null;\n            }\n            this.videoFeed = null;\n        }\n    }\n\n/***************************************************************************************************************************\n * PRIVATE AREA\n ***************************************************************************************************************************/\n\n    private videoFeed: HTMLVideoElement | null = null;\n    private recognizerRunner: RecognizerRunner;\n    private cancelled: boolean = false;\n    private timedOut: boolean = false;\n    private recognitionPaused: boolean = false;\n    private recognitionTimeoutMs: number = 30000;\n    private timeoutID: number = 0;\n    private videoRecognitionMode: VideoRecognitionMode = VideoRecognitionMode.Recognition;\n    private onScanningDone: OnScanningDone | null = null;\n\n    private constructor( videoFeed: HTMLVideoElement, recognizerRunner: RecognizerRunner )\n    {\n        this.videoFeed = videoFeed;\n        this.recognizerRunner = recognizerRunner;\n    }\n\n    private playPauseEvent()\n    {\n        if ( this.videoFeed!.paused )\n            this.cancelRecognition();\n        else\n            this.resumeRecognition( true );\n    }\n\n    private async recognitionLoop()\n    {\n        // const capBegin = performance.now();\n        const cameraFrame = captureFrame( this.videoFeed! );\n        // const capEnd = performance.now();\n        // console.log( \"Frame capture took \" + ( capEnd - capBegin ) + \" ms\" );\n        // const procBegin = performance.now();\n        const processResult = await this.recognizerRunner.processImage( cameraFrame );\n        // const procEnd = performance.now();\n        // console.log( \"Wasm process took \" + ( procEnd - procBegin ) + \" ms\" );\n        if ( processResult == RecognizerResultState.Valid || this.cancelled || this.timedOut )\n        {\n            if ( this.videoRecognitionMode == VideoRecognitionMode.Recognition || this.cancelled )\n            {\n                // valid results, clear the timeout and invoke the callback\n                this.clearTimeout();\n                this.onScanningDone!( processResult );\n                // after returning from callback, resume scanning if not paused\n            }\n            else\n            {\n                // in test mode - reset the recognizers and continue the loop indefinitely\n                await this.recognizerRunner.resetRecognizers( true );\n                // clear any time outs\n                this.clearTimeout();\n            }\n        }\n        else if ( processResult != RecognizerResultState.Empty )\n        {\n            if ( this.timeoutID == 0 )\n            {\n                // first non-empty result - start timeout\n                this.timeoutID = window.setTimeout\n                (\n                    () => { this.timedOut = true; },\n                    this.recognitionTimeoutMs\n                );\n            }\n        }\n        if ( !this.recognitionPaused )\n        {\n            // ensure browser events are processed and then recognize another frame\n            setTimeout( () => { this.recognitionLoop(); }, 1 );\n        }\n    }\n\n    private clearTimeout()\n    {\n        if ( this.timeoutID > 0 )\n        {\n            window.clearTimeout( this.timeoutID );\n            this.timeoutID = 0;\n        }\n    }\n}\n\n// inspired by https://unpkg.com/browse/scandit-sdk@4.6.1/src/lib/cameraAccess.ts\nconst backCameraKeywords: string[] = [\n    \"rear\",\n    \"back\",\n    \"rck\",\n    \"arrire\",\n    \"trasera\",\n    \"trs\",\n    \"traseira\",\n    \"posteriore\",\n    \"\",\n    \"\",\n    \"\",\n    \"\", // alternative\n    \"\", // alternative\n    \"\", // alternative\n    \"\",\n    \"\",\n    \"\",\n    \"arka\",\n    \"achterzijde\",\n    \"\",\n    \"baksidan\",\n    \"bagside\",\n    \"sau\",\n    \"bak\",\n    \"tylny\",\n    \"takakamera\",\n    \"belakang\",\n    \"\",\n    \"\",\n    \"spate\",\n    \"hts\",\n    \"zadn\",\n    \"darrere\",\n    \"zadn\",\n    \"\",\n    \"stranja\",\n    \"belakang\",\n    \"\"\n  ];\n\nfunction isBackCameraLabel( label: string ): boolean\n{\n    const lowercaseLabel = label.toLowerCase();\n\n    return backCameraKeywords.some( keyword => lowercaseLabel.includes( keyword ) );\n}\n\nclass SelectedCamera {\n    readonly deviceId: string;\n    readonly groupId: string;\n    readonly facing: PreferredCameraType;\n    readonly label: string;\n\n    constructor( mdi: MediaDeviceInfo, facing: PreferredCameraType )\n    {\n        this.deviceId = mdi.deviceId;\n        this.facing = facing;\n        this.groupId = mdi.groupId;\n        this.label = mdi.label;\n    }\n}\n\nasync function selectCamera( preferredCameraType: PreferredCameraType ): Promise< SelectedCamera | null >\n{\n    let frontCameras: SelectedCamera[] = [];\n    let backCameras: SelectedCamera[] = [];\n\n    {\n        let devices = await navigator.mediaDevices.enumerateDevices();\n        // if permission is not given, label of video devices will be empty string\n        if ( devices.filter( device => device.kind === 'videoinput' ).every( device => device.label === \"\" ) )\n        {\n            const stream = await navigator.mediaDevices.getUserMedia( { video: { facingMode: { ideal: 'environment' } }, audio: false } );\n\n            // enumerate devices again - now the label field should be non-empty, as we have a stream active (even if we didn't get persistent permission for camera)\n            devices = await navigator.mediaDevices.enumerateDevices();\n\n            // close the stream, as we don't need it anymore\n            stream.getTracks().forEach( track => track.stop() );\n        }\n\n        const cameras = devices.filter( device => device.kind === 'videoinput' );\n        for ( let i in cameras )\n        {\n            const camera = cameras[ i ];\n            if ( isBackCameraLabel( camera.label ) )\n            {\n                backCameras.push( new SelectedCamera( camera, PreferredCameraType.BackFacingCamera ) );\n            }\n            else\n            {\n                frontCameras.push( new SelectedCamera( camera, PreferredCameraType.FrontFacingCamera ) );\n            }\n        }\n    }\n    if ( frontCameras.length > 0 || backCameras.length > 0 )\n    {\n        // decide from which array the camera will be selected\n        let cameraPool: SelectedCamera[] = (backCameras.length > 0 ? backCameras : frontCameras);\n        // if there is at least one back facing camera and user prefers back facing camera, use that as a selection pool\n        if ( preferredCameraType === PreferredCameraType.BackFacingCamera && backCameras.length > 0 )\n        {\n            cameraPool = backCameras;\n        }\n        // if there is at least one front facing camera and user prefers front facing camera, use that as a selection pool\n        if ( preferredCameraType === PreferredCameraType.FrontFacingCamera && frontCameras.length > 0 )\n        {\n            cameraPool = frontCameras;\n        }\n        // otherwise use whichever pool is non-empty\n\n        // sort camera pool by label\n        cameraPool = cameraPool.sort( ( camera1, camera2 ) => camera1.label.localeCompare( camera2.label ) );\n\n        // Check if cameras are labeled with resolution information, take the higher-resolution one in that case\n        // Otherwise pick the first camera\n        {\n            let selectedCameraIndex = 0;\n\n            const cameraResolutions: number[] = cameraPool.map\n            (\n                camera =>\n                {\n                    const match = camera.label.match( /\\b([0-9]+)MP?\\b/i );\n                    if (match != null)\n                    {\n                        return parseInt( match[1], 10 );\n                    }\n                    else\n                    {\n                        return NaN;\n                    }\n                }\n            );\n\n            if ( !cameraResolutions.some( cameraResolution => isNaN( cameraResolution ) ) )\n            {\n                selectedCameraIndex = cameraResolutions.lastIndexOf( Math.max( ...cameraResolutions ) );\n            }\n\n            return cameraPool[ selectedCameraIndex ];\n        }\n    }\n    else\n    {\n        // no cameras available on the device\n        return null;\n    }\n}\n","import { defaultWasmModuleName } from \"../defaultWasmModule\"\n\n/**\n * Function that will be called during loading of the SDK.\n * @param loadPercentage Number between 0 and 100 indicating the loading progress.\n */\nexport type LoadProgressCallback = ( loadPercentage: number ) => void;\n\nexport type OptionalLoadProgressCallback = LoadProgressCallback | null;\n\n/**\n * Settings object for function loadWasmModule.\n */\nexport class WasmSDKLoadSettings\n{\n    /**\n     * License key for unlocking the WebAssembly module.\n     * License key is bound to the domain name from which the application is served.\n     */\n    licenseKey: string;\n\n    /**\n     * Whether or not WASM should be loaded on the WebWorker (recommended).\n     * Set this to false only for debugging purposes, as performing image processing tasks\n     * on UI thread may reduce the page responsiveness.\n     */\n    useWebWorker: boolean = true;\n\n    /**\n     * Name of the file containing the WebAssembly module.\n     * Change this only if you have renamed the original WASM and its support JS file\n     * for your purposes.\n     */\n    wasmModuleName: string = defaultWasmModuleName;\n\n    /**\n     * Write a hello message to the javascript console when license check is successfully performed.\n     * Hello message will contain the name and version of the SDK, which are required information for\n     * all support tickets.\n     */\n    allowHelloMessage: boolean = true;\n\n    /**\n     * Optional callback function that will report the SDK loading progress.\n     * This can be useful for displaying progress bar for users on slow connections.\n     */\n    loadProgressCallback: OptionalLoadProgressCallback = null;\n\n    /**\n     * @param licenseKey License key for unlocking the WebAssembly module.\n     */\n    constructor( licenseKey: string )\n    {\n        this.licenseKey = licenseKey;\n    }\n};\n","export const defaultWasmModuleName = 'BlinkIDWasmSDK';\n","import { WasmSDKLocal } from \"./local/LocalSDKBackend\"\nimport { WasmSDKWorker } from \"./worker/WorkerSDKBackend\"\nimport { Recognizer, RecognizerRunner, WasmSDK } from \"./DataStructures\"\nimport { MetadataCallbacks } from \"./MetadataCallbacks\"\nimport { WasmSDKLoadSettings } from \"./WasmLoadSettings\"\nimport { convertEmscriptenStatusToProgress } from './LoadProgressUtils'\n\nexport * from \"./DataStructures\"\nexport * from \"./MetadataCallbacks\"\nexport * from \"./FrameCapture\"\nexport * from \"./VideoRecognizer\"\nexport * from '../Recognizers/SuccessFrameGrabberRecognizer'\nexport * from './WasmLoadSettings'\n\n\n// taken from https://stackoverflow.com/a/2117523/213057\nfunction uuidv4(): string\n{\n  return (([1e7] as any)+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, (c: any) =>\n    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n  );\n}\n\nfunction getUserID(): string\n{\n    let userId = localStorage.getItem( 'mb-user-id' );\n    if ( userId == null )\n    {\n        userId = uuidv4();\n        localStorage.setItem( 'mb-user-id', userId );\n    }\n    return userId;\n}\n\n/**\n * Checks if browser is supported by the SDK. The minimum requirements for the browser is\n * the support for WebAssembly. If your browser does not support executing WebAssembly,\n * this function will return `false`.\n */\nexport function isBrowserSupported(): boolean\n{\n    // based on https://stackoverflow.com/a/47880734\n    try {\n        if ( typeof WebAssembly === \"object\" && typeof WebAssembly.instantiate === \"function\" ) {\n            const module = new WebAssembly.Module( Uint8Array.of( 0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00 ) );\n            if ( module instanceof WebAssembly.Module )\n                return new WebAssembly.Instance( module ) instanceof WebAssembly.Instance;\n        }\n    } catch ( ignored ) {}\n    return false;\n}\n\n/**\n * Asynchronously loads and compiles the WebAssembly module.\n * @param loadSettings Object defining the settings for loading the WebAssembly module.\n * @returns Promise that resolves if WebAssembly module was successfully loaded and rejects if not.\n */\nexport async function loadWasmModule( loadSettings: WasmSDKLoadSettings ): Promise< any >\n{\n    return new Promise< any >\n    (\n        async ( resolve: any, reject: any ) =>\n        {\n            if ( loadSettings.licenseKey === null || loadSettings.licenseKey === undefined )\n            {\n                reject( \"Missing license key!\" );\n                return;\n            }\n            if ( !loadSettings.wasmModuleName )\n            {\n                reject( \"Missing WASM module name!\" );\n                return;\n            }\n            // obtain user ID from local storage\n            const userId = getUserID();\n            if ( loadSettings.useWebWorker )\n            {\n                try\n                {\n                    // prepare the worker\n                    const wasmSDK = await WasmSDKWorker.createWasmWorker( new Worker( './MicroblinkSDK.worker.js' ), loadSettings, userId );\n                    resolve( wasmSDK );\n                }\n                catch ( initError )\n                {\n                    reject( initError );\n                }\n            }\n            else\n            {\n                const loaderFunc = ( self as { [key: string]: any } )[ loadSettings.wasmModuleName ];\n                let module = undefined;\n                if ( loadSettings.loadProgressCallback != null )\n                {\n                    module = {\n                        'setStatus': ( text: string ) =>\n                        {\n                            loadSettings.loadProgressCallback!( convertEmscriptenStatusToProgress( text ) );\n                        }\n                    };\n                }\n                loaderFunc( module ).then\n                (\n                    ( wasmModule: any ) =>\n                    {\n                        try\n                        {\n                            wasmModule.initializeWithLicenseKey( loadSettings.licenseKey, userId, loadSettings.allowHelloMessage);\n                            resolve( new WasmSDKLocal( wasmModule ) );\n                            return;\n                        }\n                        catch( licenseError )\n                        {\n                            reject( licenseError );\n                            return;\n                        }\n                    },\n                    ( reason: any ) =>\n                    {\n                        console.log( \"Failed to load WASM. Reason: \" + reason );\n                        reject( reason );\n                        return;\n                    }\n                );\n            }\n        }\n    );\n}\n\n/**\n * Function for creating a new RecognizerRunner.\n * Note that it is currently not possible to have multiple instances of RecognizerRunner per instance of WasmSDK. Attempt to create new instance of RecognizerRunner\n * prior deleting the previous one will fail.\n * @param wasmSDK Instance of WasmSDK which will be used to communicate with the WebAssembly module.\n * @param recognizers Array of recognizers that will be used by RecognizerRunner.\n * @param allowMultipleResults Whether or not it is allowed to return multiple results from single recognition session. See README.md for more information.\n * @param metadataCallbacks\n */\nexport async function createRecognizerRunner( wasmSDK: WasmSDK, recognizers: Array< Recognizer >, allowMultipleResults: boolean = false, metadataCallbacks: MetadataCallbacks = {} ): Promise< RecognizerRunner >\n{\n    return wasmSDK.mbWasmModule.createRecognizerRunner( recognizers, allowMultipleResults, metadataCallbacks );\n}\n","/**\n * Possible formats of barcodes that can be detected. This enum will be returned\n * as part of BarcodeRecognizerResult interface.\n */\nexport enum BarcodeFormat\n{\n    /** Indicates that no barcode has been detected. */\n    NONE = 0,\n    /** Indicates that QR code has been detected. */\n    QR_CODE,\n    /** Indicates that Data Matrix 2D barcode has been detected. */\n    DATA_MATRIX,\n    /** Indicates that UPC E 1D barcode has been detected. */\n    UPC_E,\n    /** Indicates that UPC A 1D barcode has been detected. */\n    UPC_A,\n    /** Indicates that EAN 8 1D barcode has been detected. */\n    EAN_8,\n    /** Indicates that EAN 13 1D barcode has been detected. */\n    EAN_13,\n    /** Indicates that Code 128 1D barcode has been detected. */\n    CODE_128,\n    /** Indicates that Code 39 1D barcode has been detected. */\n    CODE_39,\n    /** Indicates that ITF 1D barcode has been detected. */\n    ITF,\n    /** Indicates that Aztec 2D barcode has been detected. */\n    AZTEC_BARCODE,\n    /** Indicates that PDF417 2D barcode has been detected. */\n    PDF417_BARCODE\n}\n\n/**\n * Data extracted from barcode.\n */\nexport interface BarcodeData\n{\n    /** Format of recognized barcode. */\n    readonly barcodeFormat: BarcodeFormat;\n\n    /**\n     * True if returned result is uncertain, i.e. if scanned barcode was incomplete (i.e.\n     * (has parts of it missing).\n     */\n    readonly uncertain: boolean;\n\n    /** String representation of data inside barcode. */\n    readonly stringData: string;\n\n    /** The raw bytes contained inside barcode. */\n    readonly rawBytes: Uint8Array;\n}\n","import { Recognizer, RecognizerResult, RecognizerSettings, MBDate, WasmSDK } from '../../../MicroblinkSDK/DataStructures'\nimport { BarcodeData } from '../../BlinkBarcode/BarcodeData'\n\n/**\n * A settings object that is used for configuring the IdBarcodeRecognizer.\n */\nexport class IdBarcodeRecognizerSettings implements RecognizerSettings\n{}\n\n/**\n * The result of image recognition when using the IdBarcodeRecognizer.\n */\nexport interface IdBarcodeRecognizerResult extends RecognizerResult\n{\n\n    /**\n     *  THe additional address information of the document owner.\n     */\n    readonly additionalAddressInformation: string;\n\n    /**\n     *  The additional name information of the document owner.\n     */\n    readonly additionalNameInformation: string;\n\n    /**\n     *  The address of the document owner.\n     */\n    readonly address: string;\n\n    /**\n     *  The raw, unparsed barcode data.\n     */\n    readonly barcodeData: BarcodeData;\n\n    /**\n     *  The date of birth of the document owner.\n     */\n    readonly dateOfBirth: MBDate;\n\n    /**\n     *  The date of expiry of the document.\n     */\n    readonly dateOfExpiry: MBDate;\n\n    /**\n     *  The date of issue of the document.\n     */\n    readonly dateOfIssue: MBDate;\n\n    /**\n     *  The additional number of the document.\n     */\n    readonly documentAdditionalNumber: string;\n\n    /**\n     *  The document number.\n     */\n    readonly documentNumber: string;\n\n    /**\n     *  The document type deduced from the recognized barcode\n     */\n    readonly documentType: IdBarcodeDocumentType;\n\n    /**\n     *  The employer of the document owner.\n     */\n    readonly employer: string;\n\n    /**\n     * The additional privileges granted to the driver license owner.\n     */\n    readonly endorsements: string;\n\n    /**\n     *  The first name of the document owner.\n     */\n    readonly firstName: string;\n\n    /**\n     *  The full name of the document owner.\n     */\n    readonly fullName: string;\n\n    /**\n     *  The issuing authority of the document.\n     */\n    readonly issuingAuthority: string;\n\n    /**\n     *  The last name of the document owner.\n     */\n    readonly lastName: string;\n\n    /**\n     *  The marital status of the document owner.\n     */\n    readonly maritalStatus: string;\n\n    /**\n     *  The nationality of the documet owner.\n     */\n    readonly nationality: string;\n\n    /**\n     *  The personal identification number.\n     */\n    readonly personalIdNumber: string;\n\n    /**\n     *  The place of birth of the document owner.\n     */\n    readonly placeOfBirth: string;\n\n    /**\n     *  The profession of the document owner.\n     */\n    readonly profession: string;\n\n    /**\n     *  The race of the document owner.\n     */\n    readonly race: string;\n\n    /**\n     *  The religion of the document owner.\n     */\n    readonly religion: string;\n\n    /**\n     *  The residential stauts of the document owner.\n     */\n    readonly residentialStatus: string;\n\n    /**\n     * The restrictions to driving privileges for the driver license owner.\n     */\n    readonly restrictions: string;\n\n    /**\n     *  The sex of the document owner.\n     */\n    readonly sex: string;\n\n    /**\n     * The type of vehicle the driver license owner has privilege to drive.\n     */\n    readonly vehicleClass: string;\n}\n\n/**\n * The ID Barcode Recognizer is used for scanning barcodes on ID documents.\n */\nexport interface IdBarcodeRecognizer extends Recognizer\n{\n    /** Returns the currently applied IdBarcodeRecognizerSettings. */\n    currentSettings(): Promise< IdBarcodeRecognizerSettings >\n\n    /** Applies new settings to the recognizer. */\n    updateSettings( newSettings: IdBarcodeRecognizerSettings ): Promise< void >;\n\n    /** Returns the current result of the recognition. */\n    getResult(): Promise< IdBarcodeRecognizerResult >;\n}\n\n/**\n * This function is used to create a new instance of `IdBarcodeRecognizer`.\n * @param wasmSDK Instance of WasmSDK which will be used to communicate with the WebAssembly module.\n */\nexport async function createIdBarcodeRecognizer( wasmSDK: WasmSDK ): Promise< IdBarcodeRecognizer >\n{\n    return wasmSDK.mbWasmModule.newRecognizer( \"IdBarcodeRecognizer\" ) as Promise< IdBarcodeRecognizer >;\n}\n\n/**\n * Represents the type of scanned document\n */\nexport enum IdBarcodeDocumentType\n{\n    /**\n     * No document was scanned\n     */\n    None = 0,\n\n    /**\n     * AAMVACompliant document was scanned\n     */\n    AAMVACompliant,\n\n    /**\n     * ArgentinaID document was scanned\n     */\n    ArgentinaID,\n\n    /**\n     * ArgentinaDL document was scanned\n     */\n    ArgentinaDL,\n\n    /**\n     * ColombiaID document was scanned\n     */\n    ColombiaID,\n\n    /**\n     * ColombiaDL document was scanned\n     */\n    ColombiaDL,\n\n    /**\n     * NigeriaVoterID document was scanned\n     */\n    NigeriaVoterID,\n\n    /**\n     * NigeriaDL document was scanned\n     */\n    NigeriaDL,\n\n    /**\n     * PanamaID document was scanned\n     */\n    PanamaID,\n\n    /**\n     * SouthAfricaID document was scanned\n     */\n    SouthAfricaID\n}\n","import { MBDate } from '../../../MicroblinkSDK/DataStructures'\n\n/**\n * Supported MRTD document types\n */\nexport enum MrtdDocumentType\n{\n    MRTD_TYPE_UNKNOWN = 0,\n    /** Identity card */\n    MRTD_TYPE_IDENITY_CARD,\n    /** Passport */\n    MRTD_TYPE_PASSPORT,\n    /** Visa */\n    MRTD_TYPE_VISA,\n    /** US Green Card */\n    MRTD_TYPE_GREEN_CARD,\n    /** Malaysian PASS type IMM13P */\n    MRTD_TYPE_MYS_PASS_IMM13P\n}\n\n/**\n * Represents data extracted from MRZ (Machine Readable Zone) of Machine Readable Travel Document (MRTD).\n */\nexport interface MrzResult\n{\n    /**\n     * The alien number. Contains empty string if not available.\n     * Exists only on US Green Cards. To see which document was scanned use {@link documentType}.\n     */\n    readonly alienNumber: string;\n\n    /**\n     * The application receipt number. Contains empty string if not available.\n     * Exists only on US Green Cards. To see which document was scanned use {@link documentType}.\n     */\n    readonly applicationReceiptNumber: string;\n\n    /**\n     * The holder's date of birth\n     */\n    readonly dateOfBirth: MBDate;\n\n    /**\n     * The date of expiry\n     */\n    readonly dateOfExpiry: MBDate;\n\n    /**\n     * The document code. Document code contains two characters. For MRTD the first character shall\n     * be A, C or I. The second character shall be discretion of the issuing State or organization except\n     * that V shall not be used, and `C` shall not be used after `A` except in the crew member certificate.\n     * On machine-readable passports (MRP) first character shall be `P` to designate an MRP. One additional\n     * letter may be used, at the discretion of the issuing State or organization, to designate a particular\n     * MRP. If the second character position is not used for this purpose, it shall be filled by the filter\n     * character <code>&lt;</code>.\n     */\n    readonly documentCode: string;\n\n    /**\n     * The document number. Document number contains up to 9 characters.\n     * Element does not exist on US Green Card. To see which document was scanned use {@link documentType}.\n     */\n    readonly documentNumber: string;\n\n    /**\n     * The MRTD document type of recognized document.\n     */\n    readonly documentType: MrtdDocumentType;\n\n    /**\n     * The gender of the card holder. Gender is specified by use of the single initial, capital letter F for female,\n     * M for male or <code>&lt;</code> for unspecified.\n     */\n    readonly gender: string;\n\n    /**\n     * The immigrant case number. Contains empty string if not available.\n     * Exists only on US Green Cards. To see which document was scanned use {@link #documentType}.\n     */\n    readonly immigrantCaseNumber: string;\n\n    /**\n     * The three-letter or two-letter code which indicate the issuing State. Three-letter codes are based\n     * on Aplha-3 codes for entities specified in ISO 3166-1, with extensions for certain States. Two-letter\n     * codes are based on Aplha-2 codes for entities specified in ISO 3166-1, with extensions for certain States.\n     */\n    readonly issuer: string;\n\n    /**\n     * The full issuer name that is expanded from the three-letter or two-letter code which indicate\n     * the issuing State.\n     */\n    readonly issuerName: string;\n\n    /**\n     * Returns nationality of the holder represented by a three-letter or two-letter code. Three-letter\n     * codes are based on Alpha-3 codes for entities specified in ISO 3166-1, with extensions for certain\n     * States. Two-letter codes are based on Aplha-2 codes for entities specified in ISO 3166-1, with\n     * extensions for certain States.\n     */\n    readonly nationality: string;\n\n    /**\n     * Full nationality of the holder, which is expanded from the three-letter or two-letter\n     * nationality code.\n     */\n    readonly nationalityName: string;\n\n    /**\n     * The first optional data. Contains empty string if not available.\n     * Element does not exist on US Green Card. To see which document was scanned use {@link #documentType}.\n     */\n    readonly opt1: string;\n\n    /**\n     * The second optional data. Contains empty string if not available.\n     * Element does not exist on Passports and Visas. To see which document was scanned use {@link #documentType}.\n     */\n    readonly opt2: string;\n\n    /**\n     * true if Machine Readable Zone has been parsed, false otherwise.\n     */\n    readonly parsed: boolean;\n\n    /**\n     * The primary indentifier. If there is more than one component, they are separated with space.\n     */\n    readonly primaryID: string;\n\n    /**\n     * The entire Machine Readable Zone text from ID. This text is usually used for parsing\n     * other elements.\n     * NOTE: This string is available only if OCR result was parsed successfully.\n     */\n    readonly rawMRZString: string;\n\n    /**\n     * The document code, but without additional '<' characters if they exist.\n     *\n     * @see #documentCode\n     */\n    readonly sanitizedDocumentCode: string;\n\n    /**\n     * The document number, but without additional '<' characters if they exist.\n     *\n     * @see #documentNumber\n     */\n    readonly sanitizedDocumentNumber: string;\n\n    /**\n     * The issuer, but without additional '<' characters if they exist.\n     *\n     * @see #issuer\n     */\n    readonly sanitizedIssuer: string;\n\n    /**\n     * The nationality, but without additional '<' characters if they exist.\n     *\n     * @see #nationality\n     */\n    readonly sanitizedNationality: string;\n\n    /**\n     * The opt1 field, but without additional '<' characters if they exist.\n     *\n     * @see #opt1\n     */\n    readonly sanitizedOpt1: string;\n\n    /**\n     * The opt2 field, but without additional '<' characters if they exist.\n     *\n     * @see #opt2\n     */\n    readonly sanitizedOpt2: string;\n\n    /**\n     * The secondary identifier. If there is more than one component, they are separated with space.\n     */\n    readonly secondaryID: string;\n\n    /**\n     * True if all check digits inside MRZ are correct, false otherwise.\n     */\n    readonly verified: boolean;\n}\n","import * as MicroblinkSDK from '@microblink/blinkid-in-browser-sdk'\n\nconst loadingScreen = document.getElementById( \"loadingScreen\" ) as HTMLDivElement;\nconst loadProgress  = document.getElementById( 'loadProgress' ) as HTMLProgressElement;\n\n// first check if browser is supported\nif ( !MicroblinkSDK.isBrowserSupported() )\n{\n    loadingScreen.innerHTML = \"<h1>Your browser is not supported by this SDK! <h1/>\";\n}\nelse\n{\n    // create a load settings, defining the license key and name of the WebAssembly module\n    const loadSettings = new MicroblinkSDK.WasmSDKLoadSettings( getLicenseKey() );\n    // in order to provide better UX, display progress bar while loading the SDK\n    loadSettings.loadProgressCallback = ( progress: number ) =>\n    {\n        loadProgress.value = progress;\n    }\n\n    // asynchronously load and compile the WebAssembly module.\n    MicroblinkSDK.loadWasmModule( loadSettings ).then\n    (\n        // function called when WebAssembly module gets ready\n        ( wasmSDK: MicroblinkSDK.WasmSDK ) =>\n        {\n            console.log( \"WASM loaded successfully!\" );\n\n            // hide loading screen and display scan button\n            loadingScreen.hidden = true;\n            document.getElementById( 'btnStart' )!.hidden = false;\n\n            // create an instance of MyApp and attach it to global window object\n            const app = new MyApp( wasmSDK );\n\n            // attach the app to the window object, so that it will be accessible from HTML events\n            ( window as any ).app = app;\n        },\n        // function called when there is an error in loading the WebAssembly module\n        ( reason: any ) =>\n        {\n            console.error( \"Failed to load WASM! Reason: \" + reason );\n            alert( \"Failed to load WASM! Reason: \" + reason );\n            loadingScreen.innerHTML = \"<h1>Failed to load WASM! Reason: \" + reason + \"</h1>\";\n        }\n    );\n}\n\nclass MyApp\n{\n    // reference to Wasm SDK\n    private wasmSDK: MicroblinkSDK.WasmSDK;\n\n    // canvas on which metadata will be drawn\n    private detectionResult: HTMLCanvasElement;\n    // HTML video element displaying camera preview\n    private cameraFeed: HTMLVideoElement;\n    // cached 2D rendering context for detectionResult canvas\n    private drawContext: CanvasRenderingContext2D;\n\n    constructor( sdk: MicroblinkSDK.WasmSDK )\n    {\n        this.wasmSDK = sdk;\n        this.detectionResult = document.getElementById( 'cameraFeedback' ) as HTMLCanvasElement;\n        this.cameraFeed = document.getElementById( 'cameraFeed' ) as HTMLVideoElement;\n        this.drawContext = this.detectionResult.getContext( '2d' )!;\n    }\n\n    // this method gets called when user clicks the \"Start scanning\" button\n    async startScanning()\n    {\n        // 1. create a recognizer object, which will be used to recognize the stream of images\n        // In this example, we create a MrtdRecognizer, which knows how to scan Machine Readable Zone\n        // from various ID documents.\n        const mrtdRecognizer = await MicroblinkSDK.createMrtdRecognizer( this.wasmSDK );\n\n        // we will also create IdBarcodeRecognizer, which knows how to scan barcodes from various\n        // ID documents\n        const idBarcodeRecognizer = await MicroblinkSDK.createIdBarcodeRecognizer( this.wasmSDK );\n\n        // 2. (optionally) create a callbacks object that will receive recognition events, such as detected object location etc.\n        const callbacks: MicroblinkSDK.MetadataCallbacks = {\n            onQuadDetection: ( quad: MicroblinkSDK.DisplayableQuad ) => {\n                this.drawQuad( quad );\n            }\n        }\n\n        // 3. create a RecognizerRunner object, which orchestrates the recognition with one or more recognizer objects\n        const recognizerRunner = await MicroblinkSDK.createRecognizerRunner(\n            this.wasmSDK,                               // Wasm SDK to use\n            [ mrtdRecognizer, idBarcodeRecognizer ],    // list of recognizer objects that will be associated with created RecognizerRunner object\n            false,                                      // (optional) should recognition pipeline stop as soon as first recognizer in chain finished recognition\n            callbacks                                   // (optional) callbacks object that will receive recognition events\n        );\n\n        // 4. create a VideoRecognizer object and attach it to HTMLVideoElement that will be used for displaying the camera feed\n        const videoRecognizer = await MicroblinkSDK.VideoRecognizer.createVideoRecognizerFromCameraStream( this.cameraFeed, recognizerRunner );\n\n        // hide button and unhide display message\n        document.getElementById( 'btnStart' )!.hidden = true;\n        document.getElementById( 'cameraMessage' )!.hidden = false;\n\n        // 5. start the recognition and await for the results\n        const processResult = await videoRecognizer.recognize();\n\n        // 6. if recognition was successful, obtain the results and display them\n        if ( processResult != MicroblinkSDK.RecognizerResultState.Empty )\n        {\n            let alertMessage = '';\n\n            const mrtdResult = await mrtdRecognizer.getResult();\n            if ( mrtdResult.state != MicroblinkSDK.RecognizerResultState.Empty )\n            {\n                console.log( mrtdResult );\n                alertMessage += \"Hello, \" + mrtdResult.mrzResult.secondaryID + ' ' + mrtdResult.mrzResult.primaryID + '! You were born on ' + mrtdResult.mrzResult.dateOfBirth.year + '-' + mrtdResult.mrzResult.dateOfBirth.month + '-' + mrtdResult.mrzResult.dateOfBirth.day + '!\\n';\n            }\n\n            const idBarcodeResult = await idBarcodeRecognizer.getResult();\n            if ( idBarcodeResult.state != MicroblinkSDK.RecognizerResultState.Empty )\n            {\n                console.log( idBarcodeResult );\n                alertMessage += \"Hello, \" + idBarcodeResult.firstName + ' ' + idBarcodeResult.lastName + '! You were born on ' + idBarcodeResult.dateOfBirth.year + '-' + idBarcodeResult.dateOfBirth.month + '-' + idBarcodeResult.dateOfBirth.day + '!\\n';\n            }\n\n            if ( alertMessage.length != 0 )\n            {\n                alert( alertMessage );\n            }\n        }\n\n        // 7. release all resources allocated on the WebAssembly heap and associated with camera stream\n\n        // release browser resources associated with the camera stream\n        videoRecognizer.releaseVideoFeed();\n        // release memory on WebAssembly heap used by the RecognizerRunner\n        recognizerRunner.delete();\n        // release memory on WebAssembly heap used by the recognizers\n        mrtdRecognizer.delete();\n        idBarcodeRecognizer.delete();\n\n        // hide message and show the scan button again\n        document.getElementById( 'btnStart' )!.hidden = false;\n        document.getElementById( 'cameraMessage' )!.hidden = true;\n\n        // clear any leftovers drawn to canvas\n        this.clearDrawCanvas();\n    }\n\n    // utility functions for drawing detected quadrilateral onto canvas\n    private drawQuad( quad: MicroblinkSDK.DisplayableQuad )\n    {\n        this.clearDrawCanvas();\n        this.setupColor( quad );\n\n        const ctx = this.drawContext;\n        this.applyTransform( ctx, quad.transformMatrix );\n        ctx.beginPath();\n        ctx.moveTo( quad.topLeft    .x, quad.topLeft    .y );\n        ctx.lineTo( quad.topRight   .x, quad.topRight   .y );\n        ctx.lineTo( quad.bottomRight.x, quad.bottomRight.y );\n        ctx.lineTo( quad.bottomLeft .x, quad.bottomLeft .y );\n        ctx.closePath();\n        ctx.stroke();\n    }\n\n    // this function will make sure that coordinate system associated with detectionResult canvas\n    // will match the coordinate system of the image being recognized\n    private applyTransform( ctx: CanvasRenderingContext2D, transformMatrix: Float32Array )\n    {\n        // TODO: optimization: this can be calculated once every time camera is started and browser video is resized\n        // convert point from coordinates in video into coordinates in canvas\n        const canvasAR = this.detectionResult.width / this.detectionResult.height;\n        const videoAR  = this.cameraFeed.videoWidth / this.cameraFeed.videoHeight;\n\n        let xOffset = 0;\n        let yOffset = 0;\n        let scaledVideoHeight = 0\n        let scaledVideoWidth  = 0\n\n        if ( canvasAR > videoAR ) // pillarboxing: https://en.wikipedia.org/wiki/Pillarbox\n        {\n            scaledVideoHeight = this.detectionResult.height;\n            scaledVideoWidth = videoAR * scaledVideoHeight;\n            xOffset = ( this.detectionResult.width - scaledVideoWidth ) / 2.0;\n        }\n        else                      // letterboxing: https://en.wikipedia.org/wiki/Letterboxing_(filming)\n        {\n            scaledVideoWidth = this.detectionResult.width;\n            scaledVideoHeight = scaledVideoWidth / videoAR;\n            yOffset = ( this.detectionResult.height - scaledVideoHeight ) / 2.0;\n        }\n\n        // first transform canvas for offset of video preview within the HTML video element (i.e. correct letterboxing or pillarboxing)\n        ctx.translate( xOffset, yOffset );\n        // second, scale the canvas to fit the scaled video\n        ctx.scale( scaledVideoWidth / this.cameraFeed.videoWidth, scaledVideoHeight / this.cameraFeed.videoHeight );\n\n        // finally, apply transformation from image coordinate system to\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setTransform\n        ctx.transform( transformMatrix[ 0 ], transformMatrix[ 3 ], transformMatrix[ 1 ], transformMatrix[ 4 ], transformMatrix[ 2 ], transformMatrix[ 5 ] );\n    }\n\n    private clearDrawCanvas()\n    {\n        // TODO: optimization: update this only on resize event\n        this.detectionResult.width = this.detectionResult.clientWidth;\n        this.detectionResult.height = this.detectionResult.clientHeight;\n\n        this.drawContext.clearRect( 0, 0, this.detectionResult.width, this.detectionResult.height );\n    }\n\n    private setupColor( displayable: MicroblinkSDK.Displayable )\n    {\n        const ctx = this.drawContext;\n\n        let color = '#FFFF00FF' // yellow\n        // determine color based on detection status\n        if      ( displayable.detectionStatus == MicroblinkSDK.DetectionStatus.Fail    ) color = '#FF0000FF'; // red\n        else if ( displayable.detectionStatus == MicroblinkSDK.DetectionStatus.Success ) color = '#00FF00FF'; // green\n\n        ctx.fillStyle   = color\n        ctx.strokeStyle = color\n        ctx.lineWidth = 5;\n    }\n}\n\n// a utility function for obtaining license key for both localhost and live demo on Github\nfunction getLicenseKey()\n{\n    if ( window.location.hostname == 'localhost' )\n        // valid until: 2020-08-30\n        return \"sRwAAAYJbG9jYWxob3N0r/lOPig/w35CpJnWLiw/ZJYiDFZwYqK/kA1cRcCN5ct/CCFbjudXj+A54krF7iA0qaxxnJ27Cut6gsMoAYGPOD2RYxPUstV1D+XQi45wMHn2Xi0V0LIO5nB3dWH/I+1nLUfeLCkcwxLgcLq8I8VzCsfQ2nTgNmQ4Aq/F6GjP8Hy1lXAmZdgT+uONk9FYuPPlzAUGQmIQdWnfnPHm/wwpQR2CK7H38ZEFzOi4WF1XDbMwNCeb2Zz6NzR8Xa9MyR8opPRAVAh06XZ2\"\n    else if ( window.location.hostname == 'blinkid.github.io' )\n        return \"sRwAAAYRYmxpbmtpZC5naXRodWIuaW+qBF9hW4YlTvZbRuaFVwbiD8KZM6KyFj+Gxuno8ppVrH5oPsVMXBqdigowDAY+ZokUY/jc2Wd1nrpyFP39P9e+xwhUr4CeoPrN/g4n277HKc0MyWB2FT3x8K2+zRo0XPjQxaAaD6x3aYPEgbjBO5KL0Prr6dGZLfm5rci13gQE5xBXZ++UeDzz00RM4+Oj/i6gFW8E+n7QCTmHFBaa//QmDdT2Jr9G+svdUFemdOd6wCCPvY7Gol/x5oXDz4aUSMOksnHFdCrP//8=\"\n    else\n        throw new Error( 'No license key for ' + window.location.hostname );\n}\n","export function convertEmscriptenStatusToProgress( emStatus: string ): number\n{\n    // roughly based on https://github.com/emscripten-core/emscripten/blob/1.39.11/src/shell.html#L1259\n    if ( emStatus == 'Running...' )\n    {\n        // download has completed, wasm execution has started\n        return 100;\n    }\n    else if ( emStatus.length == 0 )\n    {\n        // empty message\n        return 0;\n    }\n\n    const match = emStatus.match(/([^(]+)\\((\\d+(\\.\\d+)?)\\/(\\d+)\\)/);\n    if ( match )\n    {\n        const currentValue = parseInt( match[ 2 ] );\n        const maxValue = parseInt( match[ 4 ] );\n        return currentValue * 100 / maxValue;\n    }\n    else\n    {\n        // some other message\n        console.debug( \"Cannot parse emscripten status: \", emStatus );\n        return NaN;\n    }\n}\n","import { FullDocumentImageOptions, validateDpi, ExtensionFactors, ImageResult } from '../ImageOptions'\nimport { MrzResult } from './MrtdStructures'\nimport { Recognizer, RecognizerResult, RecognizerSettings, WasmSDK } from '../../../MicroblinkSDK/DataStructures'\n\n\n/**\n * A settings object that is used for configuring the MrtdRecognizer.\n */\nexport class MrtdRecognizerSettings implements RecognizerSettings, FullDocumentImageOptions\n{\n    /**\n     * Defines whether returning of unparsed results is allowed.\n     */\n    allowUnparsedResults = false;\n\n    /**\n     * Defines whether returning unverified results is allowed.\n     * Unverified MRZ is parsed, but check digits are incorrect.\n     */\n    allowUnverifiedResults = true;\n\n    /**\n     * Whether special characters are allowed.\n     */\n    allowSpecialCharacters = false;\n\n    // implementation of the FullDocumentImageOptions interface\n    returnFullDocumentImage        = false;\n    returnEncodedFullDocumentImage = false;\n    private _fullDocumentImageDpi  = 250;\n    get fullDocumentImageDpi() { return this._fullDocumentImageDpi; }\n    set fullDocumentImageDpi( value: number )\n    {\n        validateDpi( value );\n        this._fullDocumentImageDpi = value;\n    }\n    fullDocumentImageExtensionFactors = new ExtensionFactors();\n}\n\n/**\n * The result of image recognition when using the MrtdRecognizer.\n */\nexport interface MrtdRecognizerResult extends RecognizerResult\n{\n    /**\n     *  The full document image\n     */\n    readonly fullDocumentImage: ImageResult;\n\n    /**\n     *  The data extracted from the machine readable zone.\n     */\n    readonly mrzResult: MrzResult;\n}\n\n/**\n * The Blink ID Recognizer is used for scanning any ID document.\n */\nexport interface MrtdRecognizer extends Recognizer\n{\n    /** Returns the currently applied MrtdRecognizerSettings. */\n    currentSettings(): Promise< MrtdRecognizerSettings >\n\n    /** Applies new settings to the recognizer. */\n    updateSettings( newSettings: MrtdRecognizerSettings ): Promise< void >;\n\n    /** Returns the current result of the recognition. */\n    getResult(): Promise< MrtdRecognizerResult >;\n}\n\n/**\n * This function is used to create a new instance of `MrtdRecognizer`.\n * @param wasmSDK Instance of WasmSDK which will be used to communicate with the WebAssembly module.\n */\nexport async function createMrtdRecognizer( wasmSDK: WasmSDK ): Promise< MrtdRecognizer >\n{\n    return wasmSDK.mbWasmModule.newRecognizer( \"MrtdRecognizer\" ) as Promise< MrtdRecognizer >;\n}\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","WasmLocalRecognizerRunner","[object Object]","nativeRecognizerRunner","this","image","processImage","recognizers","allowMultipleResults","reconfigureRecognizers","error","metadataCallbacks","setJSDelegate","hardReset","resetRecognizers","detectionOnly","setDetectionOnlyMode","clearTimeoutCallback","setClearTimeoutCallback","mirrored","setCameraPreviewMirrored","delete","WasmModuleLocalProxy","realWasmModule","className","constructorArgs","nativeRecognizer","recognizerName","RecognizerRunner","WasmSDKLocal","wasmModule","mbWasmModule","nextMessageID","BaseRequestMessage","action","messageID","msgId","getNextMessageID","InitMessage","wasmLoadSettings","userId","super","wasmModuleName","licenseKey","registerLoadCallback","loadProgressCallback","allowHelloMessage","ParameterType","MetadataCallback","ImageOrientation","RecognizerResultState","DetectionStatus","CreateNewRecognizer","params","CreateRecognizerRunner","recognizerHandles","registeredMetadataCallbacks","ReconfigureRecognizerRunner","DeleteRecognizerRunner","InvokeObjectMethod","objectHandle","methodName","ProcessImage","frame","imageData","data","buffer","ResetRecognizers","RegisteredMetadataCallbacks","RegisterMetadataCallbacks","SetDetectionOnly","detectionOnlyMode","SetClearTimeoutCallback","callbackNonEmpty","SetCameraPreviewMirrored","cameraPreviewMirrored","defaultEventHandler","msg","resultMsg","success","defaultResultEventHandler","successResolver","RemoteRecognizer","wasmWorker","remoteObjHandle","wasmSDKWorker","Messages.InvokeObjectMethod","handler","postMessage","newSettings","parameter","type","Messages.ParameterType","Any","createRegisteredCallbacks","Messages.RegisteredMetadataCallbacks","onDebugText","onDetectionFailed","onPointsDetection","onQuadDetection","onFirstSideResult","onGlare","RemoteRecognizerRunner","deleted","Messages.ProcessImage","response","state","recognitionState","postTransferrableMessage","getRecognizerHandles","Messages.ReconfigureRecognizerRunner","Messages.RegisterMetadataCallbacks","postMessageAndRegisterCallbacks","Messages.ResetRecognizers","Messages.SetDetectionOnly","Messages.SetClearTimeoutCallback","registerClearTimeoutCallback","Messages.SetCameraPreviewMirrored","Messages.DeleteRecognizerRunner","remoteRecognizers","recognizerIndex","remoteRecognizer","push","getRemoteObjectHandle","WasmModuleWorkerProxy","Messages.CreateRecognizerRunner","Messages.CreateNewRecognizer","wrappedPrameters","i","param","paramType","Recognizer","wrapParameters","WasmSDKWorker","worker","mbWasmWorker","onmessage","event","handleWorkerEvent","loadCallback","message","eventHandler","eventHandlers","getTransferrables","callback","callbackType","Messages.MetadataCallback","callbackParameters","onClearTimeout","Error","progress","initMessage","Messages.InitMessage","initEventHandler","canvas","CapturedFrame","orientation","videoFrame","PreferredCameraType","NotSupportedReason","VideoRecognitionMode","VideoRecognizerError","reason","name","VideoRecognizer","videoFeed","recognizerRunner","Recognition","cameraFeed","preferredCameraType","BackFacingCamera","navigator","mediaDevices","getUserMedia","selectedCamera","frontCameras","backCameras","devices","enumerateDevices","filter","device","kind","every","label","stream","video","facingMode","ideal","audio","getTracks","forEach","track","stop","cameras","camera","isBackCameraLabel","SelectedCamera","FrontFacingCamera","length","cameraPool","sort","camera1","camera2","localeCompare","selectedCameraIndex","cameraResolutions","map","match","parseInt","NaN","some","cameraResolution","isNaN","lastIndexOf","Math","max","selectCamera","CameraNotFound","constraints","width","min","height","deviceId","exact","controls","srcObject","facing","style","transform","errorReason","CameraInUse","CameraNotAllowed","CameraNotAvailable","MediaDevicesNotSupported","videoPath","src","currentTime","onended","videoRecognizer","cancelRecognition","videoRecognitionMode","DetectionTest","onScanningDone","recognitionTimeoutMs","paused","cancelled","recognitionPaused","clearTimeout","play","playPauseEvent","alert","addEventListener","startRecognition","pauseVideoFeed","pauseRecognition","pause","timedOut","setTimeout","recognitionLoop","resumeRecognition","cameraFrame","imageSource","imageWidth","imageHeight","HTMLVideoElement","videoWidth","videoHeight","HTMLImageElement","naturalWidth","naturalHeight","SVGImageElement","document","createElement","ctx","getContext","drawImage","pixelData","getImageData","NoRotation","captureFrame","processResult","Valid","Empty","timeoutID","window","backCameraKeywords","lowercaseLabel","toLowerCase","keyword","includes","mdi","groupId","WasmSDKLoadSettings","getUserID","localStorage","getItem","replace","c","crypto","getRandomValues","Uint8Array","toString","setItem","BarcodeFormat","IdBarcodeDocumentType","MrtdDocumentType","loadingScreen","getElementById","loadProgress","WebAssembly","instantiate","module","Module","of","Instance","ignored","MicroblinkSDK.isBrowserSupported","loadSettings","MicroblinkSDK.WasmSDKLoadSettings","location","hostname","getLicenseKey","undefined","useWebWorker","wasmSDK","createWasmWorker","Worker","initError","loaderFunc","self","setStatus","text","emStatus","console","debug","convertEmscriptenStatusToProgress","initializeWithLicenseKey","licenseError","log","MicroblinkSDK.loadWasmModule","hidden","app","MyApp","innerHTML","sdk","detectionResult","drawContext","mrtdRecognizer","newRecognizer","MicroblinkSDK.createMrtdRecognizer","idBarcodeRecognizer","MicroblinkSDK.createIdBarcodeRecognizer","callbacks","quad","drawQuad","createRecognizerRunner","MicroblinkSDK.createRecognizerRunner","MicroblinkSDK.VideoRecognizer","createVideoRecognizerFromCameraStream","recognize","MicroblinkSDK.RecognizerResultState","alertMessage","mrtdResult","getResult","mrzResult","secondaryID","primaryID","dateOfBirth","year","month","day","idBarcodeResult","firstName","lastName","releaseVideoFeed","clearDrawCanvas","setupColor","applyTransform","transformMatrix","beginPath","moveTo","topLeft","x","y","lineTo","topRight","bottomRight","bottomLeft","closePath","stroke","canvasAR","videoAR","xOffset","yOffset","scaledVideoHeight","scaledVideoWidth","translate","scale","clientWidth","clientHeight","clearRect","displayable","color","detectionStatus","MicroblinkSDK.DetectionStatus","Fail","Success","fillStyle","strokeStyle","lineWidth"],"mappings":"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"}